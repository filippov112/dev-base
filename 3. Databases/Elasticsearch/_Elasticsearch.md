#db
# Elasticsearch

**Elasticsearch** — распределённая система для полнотекстового поиска, хранения и анализа больших объёмов данных. 
Используется для логов, мониторинга, аналитики и рекомендационных систем.

- Хранит данные в хранилищах (*индексах*) в виде *документов* (JSON), которые индексируются для быстрого поиска. 
- Не использует строгие схемы и таблицы, а работает с индексами и типами документов.
- Поддерживает также числовые, геопространственные данные, временные ряды и даже вложенные объекты. 

 Основные операции:
- **Индексирование** — добавление или обновление документа.
- **Поиск** — использование Query DSL для сложных запросов.
- **Агрегации** — мощный инструмент для аналитики данных.
- **Обновление и удаление** — операции, позволяющие изменять и очищать данные.

---
#### **Индексы** — хранилища документов.
Служат для логического разделения данных по предназначению. Например - логи, пользователи, транзакции и т.д. 
Создаются с помощью REST API. 
> HTTP-запрос создаёт индекс `my_index` с 3 шардами, 1 репликой и определённой структурой хранения данных.
> ```json
> PUT /my_index
> {
>   "settings": {
>     "number_of_shards": 3,
>     "number_of_replicas": 1
>   },
>   "mappings": {
>     "properties": {
>       "title": { "type": "text" },
>       "views": { "type": "integer" },
>       "timestamp": { "type": "date" }
>     }
>   }
> }
> ```
---
#### **Документы** — JSON-объекты, содержащие данные.
Хранятся в виде **инвертированных** индексов (структура хранения данных) для быстрого поиска. 
Для получения используется REST API. 
> Этот запрос вернёт все документы из индекса `my_index`. Для фильтрации можно использовать `match`, `term` и другие виды запросов.
> ```json
> GET /my_index/_search
> {
>   "query": {
>     "match_all": {}
>   }
> }
> ```

> [!example] Например, 
> Документы: `"кот спит на солнце", "собака играет на солнце"`, 
> Инвертированный индекс будет содержать записи: `"кот" → [документ 1], "собака" → [документ 2], "на" → [документ 1, документ 2], "солнце" → [документ 1, документ 2]`. 
---

### Проектирование схемы хранения данных

Хотя Elasticsearch не требует строгой схемы, её проектирование важно для производительности и удобства использования:
- **Явное определение маппинга** — настройка типов данных и анализаторов, которые отвечают за предобработку текста перед индексированием, включая токенизацию, удаление стоп-слов и нормализацию.
- **Нормализация данных** — баланс между денормализацией (хранение связанных данных в одном документе) и ссылочной структурой (раздельное хранение с возможностью объединения при запросе).
- **Использование шаблонов индексов** — для автоматической настройки новых индексов.
- **Ротация индексов** — периодическое создание новых индексов для работы с временными данными (например, логами).

---
### Сильные и слабые стороны

Сильные:
- Высокая скорость поиска.
- Гибкость схемы — можно адаптировать структуру данных без явного определения таблиц.
- Масштабируемость благодаря шардам и репликам.
- Мощные аналитические возможности с агрегациями.
- REST API для взаимодействия.

Слабые:
- Высокое потребление памяти.
- Сложность настройки и администрирования
- Отсутствие транзакций — нет строгой консистентности, как в реляционных СУБД.
- Неэффективен для частых обновлений — обновление документа требует его повторного индексирования.

---
### Хорошие и плохие практики

Хорошие:
- Использование правильных анализаторов для точного поиска.
- Оптимизация количества шард в зависимости от нагрузки.
- Использование кэша (query cache, request cache) для ускорения повторных запросов.
- Регулярная оптимизация индексов — удаление устаревших данных и обновление маппинга.

Плохие:
- Хранение больших двоичных данных — Elasticsearch не предназначен для этого.
- Слишком много или слишком мало шард — неправильный баланс снижает производительность.
- Неиспользование агрегаций вместо сложных SQL-подобных запросов — это может снизить эффективность.
- Частые обновления и удаление документов без обновления индексов — может привести к фрагментации.

### Outer links:

