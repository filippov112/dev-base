#lang #lang-c_sharp 

---
**Атрибуты** - классы, которые позволяют встраивать в сборку дополнительные *метаданные*. 
- могут применяться как ко всему типу (классу, интерфейсу и т.д.), так и к отдельным его частям (методу, свойству и т.д.). 
- основу составляет класс `System.Attribute`, от которого образованы все остальные. 
- в .NET имеется множество встроенных классов атрибутов. 
- мы можем создавать свои собственные классы атрибутов.
- `GetCustomAttributes` - позволяет получить список атрибутов типа.

##### Ограничение применения атрибута
С помощью атрибута `AttributeUsage(AttributeTargets x, ...)` можно ограничить типы, к которым будет применяться атрибут.
- С помощью логической операции `ИЛИ` можно комбинировать эти значения. 
- `AttributeTargets` может принимать ряд значений:
	- `All`: используется всеми типами
	- `Assembly`: атрибут применяется к сборке
	- `Constructor`: атрибут применяется к конструктору
	- `Delegate`: атрибут применяется к делегату
	- `Enum`: применяется к перечислению
	- `Event`: атрибут применяется к событию
	- `Field`: применяется к полю типа
	- `Interface`: атрибут применяется к интерфейсу
	- `Method`: атрибут применяется к методу
	- `Property`: применяется к свойству
	- `Struct`: применяется к структуре

```csharp
// Ограничение применения атрибута к классам
[AttributeUsage(AttributeTargets.Class)]
class AgeValidationAttribute : Attribute
{
    //....................................
}
```

```csharp
// Применение атрибута к классам и структурам
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
```

---

### Пример:

```csharp
// Определение атрибута валидации возраста
class AgeValidationAttribute : Attribute
{
    public int Age { get;}
    public AgeValidationAttribute() { }
    public AgeValidationAttribute(int age) => Age = age;
}

// Применение атрибута к классу Person
[AgeValidation(18)] // суффикс `Attribute` указывать необязательно
public class Person
{
    public string Name { get;}
    public int Age { get; set; }
    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }
}
```

В качестве альтернативы можно использовать именованные параметры для всех свойств атрибута, если класс атрибута имеет конструктор без параметров: 

```csharp
// Альтернативное применение атрибута с именованным параметром
[AgeValidation(Age = 18)]
```

Теперь получим атрибут класса `Person` и используем его для проверки объектов данного класса:

```csharp
// Проверка объектов класса Person на соответствие возрастным ограничениям
Person tom = new Person("Tom", 35);
Person bob = new Person("Bob", 16);
bool tomIsValid = ValidateUser(tom);    // true
bool bobIsValid = ValidateUser(bob);    // false
 
Console.WriteLine($"Результат валидации Тома: {tomIsValid}");
Console.WriteLine($"Результат валидации Боба: {bobIsValid}");
 
bool ValidateUser(Person person)
{
    Type type = typeof(Person);
    // получаем все атрибуты класса Person
    object[] attributes = type.GetCustomAttributes(false);
 
    // проходим по всем атрибутам
    foreach (Attribute attr in attributes)
    {
        // если атрибут представляет тип AgeValidationAttribute
        if (attr is AgeValidationAttribute ageAttribute)
            // возвращаем результат проверки по возрасту
            return person.Age >= ageAttribute.Age;
    }
    return true;
}
```

### Inner links:
[_ Рефлексия. Типы (System.Type)](1.%20Lang/C-sharp/Рефлексия/_%20Рефлексия.%20Типы%20(System.Type).md)

### Outer links:
https://metanit.com/sharp/tutorial/14.4.php