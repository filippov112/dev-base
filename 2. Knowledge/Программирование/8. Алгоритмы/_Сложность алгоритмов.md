# Сложность алгоритмов

Для расчета сложности используется нотация O-большое. Основные шаги:
1. **Определить количество операций** — анализируется код и оценивается, сколько раз выполняются основные операции.
2. **Выделить наиболее затратные части** — найти вложенные циклы, рекурсивные вызовы и другие ресурсоемкие конструкции.
3. **Отбросить константы и незначащие слагаемые** — учитывается только доминирующий член, так как он определяет поведение при больших входных данных.
4. **Выразить сложность в O-нотации** — результат записывается в виде O(f(n)), где f(n) — функция роста числа операций.

### Таблица повышения сложности алгоритмов

|Сложность|Характерные признаки алгоритмов|
|---|---|
|**O(1)** (Константная)|Нет циклов и рекурсии, фиксированное количество операций, доступ к элементу по индексу (например, получение значения из массива).|
|**O(\log n)** (Логарифмическая)|Деление задачи на части (например, бинарный поиск), уменьшение входных данных в несколько раз за одну итерацию.|
|**O(n)** (Линейная)|Один цикл, проход по массиву, последовательное выполнение операций, линейная рекурсия.|
|**O(n \log n)** (Квазилинейная)|Разделяй и властвуй, сортировка слиянием или быстрая сортировка, построение кучи.|
|**O(n^2)** (Квадратичная)|Два вложенных цикла, сортировка пузырьком, выбором или вставками.|
|**O(n^3)** (Кубическая)|Три вложенных цикла, алгоритмы на матрицах (например, умножение матриц).|
|**O(2^n)** (Экспоненциальная)|Рекурсивный перебор всех возможных комбинаций (например, решение задачи о рюкзаке полным перебором).|
|**O(n!)** (Факториальная)|Полный перебор перестановок (например, задача коммивояжёра методом brute-force).|


### Outer links:

