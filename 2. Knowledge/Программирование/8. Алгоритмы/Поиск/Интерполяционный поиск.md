#alg_search 
# Интерполяционный поиск

**Интерполяционный поиск** — это улучшенная версия бинарного поиска, но вместо деления массива пополам делает «угадывающий» шаг, опираясь на распределение значений. Он эффективен для **равномерно распределённых данных**.

### **Пример**

Допустим, есть отсортированный массив:  
`[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]`  
Нужно найти число `70`.

1. Оцениваем, где примерно находится `70`. Алгоритм использует формулу интерполяции:
    
    `pos = left + ((target - array[left]) * (right - left)) / (array[right] - array[left])`
    
    Вставляем числа:
    
    pos=0+((70−10)×(9−0)) / (100−10) = 0+60×9/ 90=6
    
    Алгоритм сразу прыгает к **индексу 6**, где стоит `70`.
    
2. Число найдено — поиск завершён!
    

### **Сложность**

Зависит от распределения данных:  
— **Лучший случай** (угадали за один шаг) — O(1).  
— **Средний случай** — O(log log n).  
— **Худший случай** (плохо распределённые данные) — O(n).

### **Реализация на C#**

```csharp
using System;

class Program
{
    // Функция интерполяционного поиска
    static int InterpolationSearch(int[] array, int target)
    {
        int left = 0, right = array.Length - 1;

        while (left <= right && target >= array[left] && target <= array[right])
        {
            if (left == right)
            {
                if (array[left] == target) return left;
                return -1;
            }

            // Формула для вычисления позиции
            int pos = left + ((target - array[left]) * (right - left)) / (array[right] - array[left]);

            if (array[pos] == target)
                return pos; // Найдено

            if (array[pos] < target)
                left = pos + 1; // Ищем в правой части
            else
                right = pos - 1; // Ищем в левой части
        }
        return -1; // Элемент не найден
    }

    static void Main()
    {
        int[] numbers = { 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 };
        int target = 70;

        int index = InterpolationSearch(numbers, target);

        if (index != -1)
            Console.WriteLine($"Число {target} найдено в позиции {index}");
        else
            Console.WriteLine($"Число {target} не найдено");
    }
}
```

Алгоритм работает быстрее, чем бинарный поиск, если числа распределены равномерно.

### Outer links:

