#db #sql

# Шпаргалка по работе с пользовательскими функциями в различных СУБД


---

## 1. **Создание пользовательских функций (CREATE FUNCTION)**

```sql
CREATE FUNCTION function_name (parameters)
RETURNS return_type
AS
BEGIN
    -- тело функции
    RETURN value;
END;
```

### Пример создания простой функции
**Пояснение**: Эти функции принимают имя и фамилию, объединяют их и возвращают полное имя.

> **T-SQL (SQL Server):**
> ```sql
> CREATE FUNCTION dbo.GetFullName(@FirstName NVARCHAR(50), @LastName NVARCHAR(50))
> RETURNS NVARCHAR(100)
> AS
> BEGIN
>     RETURN @FirstName + ' ' + @LastName;
> END;
> ```
> 
> **PostgreSQL:**
> ```sql
> CREATE OR REPLACE FUNCTION GetFullName(FirstName VARCHAR, LastName VARCHAR)
> RETURNS VARCHAR AS $$
> BEGIN
>     RETURN FirstName || ' ' || LastName;
> END;
> $$ LANGUAGE plpgsql;
> ```
> 
> **MySQL:**
> ```sql
> CREATE FUNCTION GetFullName(FirstName VARCHAR(50), LastName VARCHAR(50))
> RETURNS VARCHAR(100)
> DETERMINISTIC
> BEGIN
>     RETURN CONCAT(FirstName, ' ', LastName);
> END;
> ```

---

## 2. **Вызов пользовательских функций**

### Пример вызова функции в запросе:

```sql
SELECT dbo.GetFullName('John', 'Doe'); -- T-SQL
SELECT GetFullName('John', 'Doe');      -- PostgreSQL / MySQL
```

---

## 3. **Функции с таблицами (табличные функции)**

Табличные функции возвращают набор данных и могут использоваться в запросах, как обычные таблицы.

### Пример табличной функции:
**Пояснение**: Эти функции возвращают список сотрудников, принадлежащих к определенному отделу.

> **T-SQL (SQL Server):**
> ```sql
> CREATE FUNCTION dbo.GetEmployeesByDepartment(@DepartmentID INT)
> RETURNS TABLE
> AS
> RETURN (
>     SELECT EmployeeID, FirstName, LastName
>     FROM Employees
>     WHERE DepartmentID = @DepartmentID
> );
> ```
> 
> **PostgreSQL:**
> ```sql
> CREATE OR REPLACE FUNCTION GetEmployeesByDepartment(DepartmentID INT)
> RETURNS TABLE(EmployeeID INT, FirstName VARCHAR, LastName VARCHAR) AS $$
> BEGIN
>     RETURN QUERY SELECT EmployeeID, FirstName, LastName
>                  FROM Employees
>                  WHERE DepartmentID = DepartmentID;
> END;
> $$ LANGUAGE plpgsql;
> ```
> 
> **MySQL:**
> ```sql
> CREATE FUNCTION GetEmployeesByDepartment(DepartmentID INT)
> RETURNS JSON
> DETERMINISTIC
> BEGIN
>     RETURN (SELECT JSON_ARRAYAGG(JSON_OBJECT('EmployeeID', EmployeeID, 'FirstName', FirstName, 'LastName', LastName))
>             FROM Employees
>             WHERE DepartmentID = DepartmentID);
> END;
> ```

---

## 4. **Использование пользовательских функций в запросах**

### Пример использования табличной функции:

```sql
SELECT * FROM dbo.GetEmployeesByDepartment(1); -- T-SQL
SELECT * FROM GetEmployeesByDepartment(1);      -- PostgreSQL / MySQL
```

---

## 5. **Изменение и удаление функций**

В большинстве СУБД для изменения функции необходимо сначала удалить ее, а затем создать заново. Однако в некоторых системах это можно сделать через `ALTER`.

### Пример удаления функции:

```sql
DROP FUNCTION dbo.GetFullName;       -- T-SQL
DROP FUNCTION GetFullName;            -- PostgreSQL
DROP FUNCTION GetFullName(VARCHAR, VARCHAR); -- MySQL
```

---

## 7. **Функции с переменным числом аргументов**

**Пояснение**: Эти функции суммируют переданные числа.

> **PostgreSQL:**
> ```sql
> CREATE OR REPLACE FUNCTION SumNumbers(VARIADIC numbers INT[])
> RETURNS INT AS $$
> DECLARE
>     total INT := 0;
> BEGIN
>     FOREACH num IN ARRAY numbers
>     LOOP
>         total := total + num;
>     END LOOP;
>     RETURN total;
> END;
> $$ LANGUAGE plpgsql;
> ```
> 
> **MySQL:**
> ```sql
> CREATE FUNCTION SumNumbers(VarArgs VARIADIC INT)
> RETURNS INT
> DETERMINISTIC
> BEGIN
>     DECLARE total INT DEFAULT 0;
>     DECLARE idx INT DEFAULT 1;
>     WHILE idx <= ARGC DO
>         SET total = total + ARGV[idx];
>         SET idx = idx + 1;
>     END WHILE;
>     RETURN total;
> END;
> ```

---

## 8. **Возврат значений и обработка ошибок**

**Пояснение**: Эти функции выполняют деление, проверяя делитель на равенство нулю, чтобы избежать ошибок.

> **T-SQL (SQL Server):**
> ```sql
> CREATE FUNCTION dbo.Divide(@Numerator INT, @Denominator INT)
> RETURNS FLOAT
> AS
> BEGIN
>     IF @Denominator = 0
>     BEGIN
>         RETURN NULL; -- или RAISERROR('Division by zero', 16, 1);
>     END
>     RETURN @Numerator * 1.0 / @Denominator;
> END;
> ```
> 
> **PostgreSQL:**
> ```sql
> CREATE OR REPLACE FUNCTION Divide(Numerator INT, Denominator INT)
> RETURNS FLOAT AS $$
> BEGIN
>     IF Denominator = 0 THEN
>         RETURN NULL; -- или RAISE EXCEPTION 'Division by zero';
>     END IF;
>     RETURN Numerator::FLOAT / Denominator;
> END;
> $$ LANGUAGE plpgsql;
> ```
> 
> **MySQL:**
> ```sql
> CREATE FUNCTION Divide(Numerator INT, Denominator INT)
> RETURNS FLOAT
> DETERMINISTIC
> BEGIN
>     IF Denominator = 0 THEN
>         RETURN NULL; -- или SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Division by zero';
>     END IF;
>     RETURN Numerator / Denominator;
> END;
> ```

