#db #sql



---

## 1. **Создание простого CTE**

```sql
WITH cte_name AS (
    SELECT column1, column2, ...
    FROM table_name
    WHERE condition
)
SELECT * FROM cte_name;
```

### Пример:
**Пояснение**: CTE `EmployeeCTE` извлекает сотрудников с зарплатой больше 50,000, и затем результаты используются в основном запросе.

```sql
WITH EmployeeCTE AS (
    SELECT FirstName, LastName, Salary
    FROM Employees
    WHERE Salary > 50000
)
SELECT * FROM EmployeeCTE;
```


---

## 2. **Использование нескольких CTE**

В одном запросе можно определить несколько CTE, которые могут ссылаться друг на друга, выполняясь последовательно сверху-вниз.

```sql
WITH cte1 AS (
    SELECT column1, column2
    FROM table1
),
cte2 AS (
    SELECT column3, column4
    FROM table2
)
SELECT * FROM cte1
JOIN cte2 ON cte1.column1 = cte2.column3;
```

### Пример
**Пояснение**: Два CTE (`DepartmentCTE` и `EmployeeCTE`) используются для объединения данных сотрудников с их департаментами.

```sql
WITH DepartmentCTE AS (
    SELECT DepartmentID, DepartmentName
    FROM Departments
),
EmployeeCTE AS (
    SELECT EmployeeID, FirstName, LastName, DepartmentID
    FROM Employees
)
SELECT e.FirstName, e.LastName, d.DepartmentName
FROM EmployeeCTE e
JOIN DepartmentCTE d ON e.DepartmentID = d.DepartmentID;
```

---

## 3. **Рекурсивные CTE**

Рекурсивные CTE позволяют выполнять итерации и решать задачи с иерархическими данными, например, иерархии сотрудников, структуры дерева и графов.

```sql
WITH RECURSIVE cte_name AS (
    -- базовый запрос
    SELECT column1, column2
    FROM table_name
    WHERE condition
    UNION ALL
    -- рекурсивный запрос
    SELECT column1, column2
    FROM table_name
    JOIN cte_name ON table_name.column = cte_name.column
)
SELECT * FROM cte_name;
```

### Пример иерархии сотрудников
**Пояснение**: Рекурсивный CTE строит иерархию сотрудников, начиная с тех, у кого нет менеджера (`ManagerID IS NULL`), и затем рекурсивно добавляет подчиненных.

> **T-SQL (SQL Server):**
> ```sql
> WITH EmployeeHierarchy AS (
>     SELECT EmployeeID, ManagerID, FirstName, LastName, 0 AS Level
>     FROM Employees
>     WHERE ManagerID IS NULL
>     UNION ALL
>     SELECT e.EmployeeID, e.ManagerID, e.FirstName, e.LastName, eh.Level + 1
>     FROM Employees e
>     JOIN EmployeeHierarchy eh ON e.ManagerID = eh.EmployeeID
> )
> SELECT * FROM EmployeeHierarchy;
> ```
> 
> **PostgreSQL, MySQL:**
> ```sql
> WITH RECURSIVE EmployeeHierarchy AS (
>     SELECT EmployeeID, ManagerID, FirstName, LastName, 0 AS Level
>     FROM Employees
>     WHERE ManagerID IS NULL
>     UNION ALL
>     SELECT e.EmployeeID, e.ManagerID, e.FirstName, e.LastName, eh.Level + 1
>     FROM Employees e
>     JOIN EmployeeHierarchy eh ON e.ManagerID = eh.EmployeeID
> )
> SELECT * FROM EmployeeHierarchy;
> ```

---

## 4. **CTE с модификацией данных (T-SQL)**

В **T-SQL (SQL Server)** можно использовать CTE для выполнения операций `UPDATE`, `DELETE`, и `INSERT`.

### Пример обновления данных с использованием CTE
**Пояснение**: CTE выбирает сотрудников с зарплатой меньше 40,000, и затем их зарплата увеличивается на 5000.

```sql
WITH SalaryCTE AS (
    SELECT EmployeeID, Salary
    FROM Employees
    WHERE Salary < 40000
)
UPDATE SalaryCTE
SET Salary = Salary + 5000;
```

---

## 5. **Использование CTE с оконными функциями**

CTE отлично сочетаются с оконными функциями, такими как `ROW_NUMBER()`, `RANK()`, и т.д.

### Пример использования CTE с `ROW_NUMBER()`:
**Пояснение**: Этот запрос использует CTE для добавления нумерации строк по зарплате и затем извлекает топ-5 сотрудников с самой высокой зарплатой.

```sql
WITH RankedEmployees AS (
    SELECT FirstName, LastName, Salary,
           ROW_NUMBER() OVER (ORDER BY Salary DESC) AS RowNum
    FROM Employees
)
SELECT * FROM RankedEmployees
WHERE RowNum <= 5;
```

---

## 6. **Модификация данных через CTE (PostgreSQL)**

В PostgreSQL можно использовать CTE для модификации данных с помощью `INSERT`, `UPDATE`, `DELETE`:

### Пример:
**Пояснение**: Этот запрос удаляет сотрудников с зарплатой меньше 30,000 и возвращает список удаленных сотрудников с их `EmployeeID`.

```sql
WITH deleted_rows AS (
    DELETE FROM Employees
    WHERE Salary < 30000
    RETURNING EmployeeID
)
SELECT * FROM deleted_rows;
```

