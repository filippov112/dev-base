#sql #db

# Ликбез по SQL

### Классификация команд

1. DDL - Data Definition Language (язык определения данных)
	*Create, Alter, Truncate, Rename, Drop*
2. DML - Data Manipulation Language (язык манипулирования данными)
	*Insert, Update, Delete*
1. DRL - Data Retrieval Language (язык извлечения данных)
	*Select*
2. TCL - Transaction Control Language (язык управления транзакциями)
	*Commit, Rollback, Savepoint*
3. DCL - Data Control Language (язык управления данными )
	*Grant, Revoke*

### <font color="#ffff00">Представления</font>

**Представление (View)** — это виртуальная таблица, которая создается на основе результата выполнения SQL-запроса. 

Основные моменты:
1. **Представления** используются для упрощения сложных запросов и ограничения доступа к данным.
2. **Обновляемые представления** могут быть использованы для изменения данных, если они удовлетворяют определенным условиям (например, отсутствие агрегатов и сложных объединений).
	1. *Представление не хранит данные*: Оно лишь отображает данные, извлекаемые из одной или нескольких таблиц.
	2. *Изменения через представление*: Когда вы выполняете операции `UPDATE`, `INSERT` или `DELETE` на обновляемом представлении, эти изменения применяются к базовым таблицам, которые участвуют в запросе, на основе которого построено это представление.
	3. *Условия для обновляемого представления*:
		   - Представление *должно ссылаться на одну таблицу* (или набор простых таблиц без сложных операций).
		   - В представлении *не должно быть агрегатных функций, join-ов, подзапросов* (`SUM()`, `COUNT()` и т.п.), подзапросов, объединений (`JOIN`), группировок (`GROUP BY`) или `DISTINCT`.
		   - Каждая строка представления должна однозначно соответствовать строке в базовой таблице.
3. **Материализованные представления** (доступны в некоторых СУБД, таких как PostgreSQL) хранят данные и требуют явного обновления, что делает их эффективными для часто повторяющихся запросов.

### <font color="#ffff00">Триггеры</font>

**Триггер** — это специальная процедура, которая автоматически выполняется при возникновении определенных событий в базе данных, таких как `INSERT`, `UPDATE`, или `DELETE` на таблице. Триггеры часто используются для обеспечения целостности данных, ведения логов или выполнения каких-либо действий при изменении данных.

**Примеры использования триггеров**
- *Логирование операций*: запись изменений в отдельные лог-таблицы.
- *Автоматическое обновление данных*: при изменении связанных записей в других таблицах.
- *Проверка и валидация данных*: перед вставкой или обновлением.
- *Каскадное удаление*: удаление зависимых данных из других таблиц.

**Ограничения триггеров**
- *Не могут напрямую вызывать другие триггеры.* Это может привести к бесконечной рекурсии.
- *Не все СУБД поддерживают `INSTEAD OF` триггеры*:
  - T-SQL (SQL Server) поддерживает триггеры типа `INSTEAD OF`, которые заменяют выполнение оригинальной команды.
  - PostgreSQL и MySQL не поддерживают этот тип триггеров.

**Виды** триггеров в зависимости от времени срабатывания:
- *BEFORE* — срабатывает *до* выполнения операции на таблице (например, перед вставкой или обновлением данных). Обычно используется для валидации данных или модификации вставляемых значений.
- *AFTER* — срабатывает *после* выполнения операции (например, после успешной вставки или удаления). Чаще используется для логирования или каскадного выполнения операций.

### <font color="#ffff00">Общие табличные выражения</font>

**Общие табличные выражения (CTE)** — это временные именованные наборы данных, которые используются в пределах одного SQL-запроса. 
CTE могут значительно *упростить сложные запросы*, *улучшить их читаемость*, а также *решать задачи, связанные с иерархией данных*, например, с использованием рекурсивных запросов.
Они поддерживаются во многих СУБД, таких как T-SQL (SQL Server), PostgreSQL и MySQL (начиная с версии 8.0).

**Ограничения CTE:**
1. *CTE не сохраняет данные*: Он существует только на время выполнения запроса. Для долговременного хранения данных следует использовать временные таблицы или материальные представления (в PostgreSQL).
2. *Рекурсивные CTE имеют лимит глубины рекурсии.* В некоторых СУБД его можно настраивать:
    - В PostgreSQL рекурсия ограничена 50 итерациями по умолчанию (можно увеличить с помощью параметра `SET statement_timeout`).
    - В MySQL можно настроить рекурсивный лимит с помощью переменной `cte_max_recursion_depth`.
3. *Рекурсивные CTE не поддерживаются в старых версиях MySQL* (до версии 8.0).

**Когда использовать CTE?**
CTE полезны, когда:
- Нужно сделать запрос более читаемым и разбить сложные запросы на логические части.
- Нужно несколько раз использовать один и тот же подзапрос в разных частях основного запроса.
- Вы хотите избежать использования временных таблиц.
- Решаете рекурсивные задачи (например, иерархии).

**CTE против подзапросов и временных таблиц**

| Характеристика          | CTE                                        | Подзапросы                           | Временные таблицы            |
|-------------------------|--------------------------------------------|--------------------------------------|------------------------------|
| *Читаемость*          | Высокая, код легче для понимания           | Менее читаемый при сложных запросах  | Разбивает запрос на части     |
| *Использование*       | Только в пределах одного запроса           | Вложенные в основном запросе         | Создаются для многократного использования |
| *Скорость*            | Могут быть менее эффективными для сложных запросов | Эффективны, но сложны для отладки    | Хранят данные физически на диске |
| *Срок жизни*          | Только во время выполнения запроса         | В пределах одного запроса            | До конца сессии или до явного удаления |

### <font color="#ffff00">Функции и процедуры</font>

**Пользовательские функции** — это программы, написанные на SQL или других языках программирования, которые выполняют определенные действия и могут возвращать значения. 
Они помогают улучшить *повторное использование кода* и поддерживают *логику бизнес-процессов* в базе данных.

**Ограничения и лучшие практики**
1. *Ограничение по производительности*: Частое использование пользовательских функций может снизить производительность, особенно в больших запросах.
2. *Отладка*: Убедитесь, что ваши функции хорошо документированы и тестированы, чтобы упростить отладку и поддержку.
3. *Пользовательские функции не могут изменять данные*: В большинстве случаев они не могут использовать оператор `UPDATE`, `INSERT` или `DELETE`.
4. *Сложные функции*: Избегайте написания сложных функций, которые затрудняют понимание и тестирование.

**Хранимые процедуры** — это программные блоки, которые выполняются на стороне сервера базы данных. Они позволяют группировать логически связанные операции и могут принимать параметры, возвращать значения и обрабатывать транзакции.

**<font color="#92d050">Различия</font>**

1. **Цель и использование**
	- *Функции*:
		- Основное назначение — вычисление значения и его возвращение.
		- Обычно используются в выражениях и могут быть вызваны из `SELECT`, `WHERE`, `JOIN` и других операторов SQL.
		- Например, функции могут выполнять арифметические операции, конкатенацию строк и т.д.
	- *Процедуры*:
		- Основное назначение — выполнение определенной последовательности операций, включая изменения данных, управление транзакциями и т.д.
		 - Не могут возвращать значение напрямую, но могут использовать выходные параметры для возврата значений или изменять данные в таблицах.
		 - Часто используются для обработки бизнес-логики, автоматизации задач и управления данными.
2. **Возврат значения**
	- *Функции*:
		- Всегда возвращают значение (или набор значений, если это табличная функция).
		- Возвращаемое значение определяется в секции `RETURN`.
	- *Процедуры*:
		- Не возвращают значение напрямую.
		- Могут использовать выходные параметры для передачи значений обратно в вызывающий код.
		- Используют `OUT` или `INOUT` параметры для передачи данных.
3. **Синтаксис**
	- *Функции*: Создаются с помощью `CREATE FUNCTION`.
		```sql
		CREATE FUNCTION GetFullName(@FirstName NVARCHAR(50), @LastName NVARCHAR(50))
		RETURNS NVARCHAR(100)
		AS
		BEGIN
			RETURN @FirstName + ' ' + @LastName;
		END;
		```
	- *Процедуры*: Создаются с помощью `CREATE PROCEDURE`.
		```sql
		CREATE PROCEDURE UpdateEmployeeSalary(@EmployeeID INT, @NewSalary DECIMAL(10, 2))
		AS
		BEGIN
			UPDATE Employees SET Salary = @NewSalary WHERE EmployeeID = @EmployeeID;
		END;
		```
4. **Контекст использования**
	- *Функции*: Можно использовать в контексте SQL-выражений, т.е. они могут быть частью `SELECT` запроса, условия `WHERE`, и т.д.
	- *Процедуры*: Вызываются отдельно с помощью команды `EXEC` или `CALL`, не могут быть встроены в выражения SQL.
5. **Управление транзакциями**
	- *Функции*: Обычно не могут изменять состояние базы данных (в большинстве СУБД), т.е. не могут выполнять операции `INSERT`, `UPDATE` или `DELETE`.
	- *Процедуры*: Могут содержать операции изменения данных и управление транзакциями (например, `COMMIT`, `ROLLBACK`).
6. **Обработка ошибок**
	- *Функции*: Не могут использовать механизм обработки ошибок (например, `TRY...CATCH` в T-SQL).
	- *Процедуры*: Могут использовать механизмы обработки ошибок, позволяя реализовать более сложную логику обработки ошибок.

### <font color="#ffff00">Переменные</font>

**Переменные** - позволяют хранить временные данные, которые могут использоваться в *запросах*, *процедурах* и *триггерах*. 

**Общие принципы работы с переменными:**
- Переменные объявляются в начале блока кода или процедуры.
- Используются для хранения значений, которые можно затем использовать в SQL-запросах.
- Переменные могут быть локальными (доступны только внутри блока кода) или глобальными (доступны в разных контекстах).

**Параметризованные запросы** — это SQL-запросы, в которых передаваемые значения заменяются параметрами. Это позволяет SQL Server компилировать и кешировать один план выполнения для разных значений параметров, снижая нагрузку на сервер и защищая от SQL-инъекций.

Пример в T-SQL:
```sql
DECLARE @Id INT = 1;
SELECT Name, Age FROM Users WHERE UserId = @Id;
```
Пример в C#:
```csharp
using (SqlCommand cmd = new SqlCommand("SELECT Name, Age FROM Users WHERE UserId = @Id", conn))
{
    cmd.Parameters.AddWithValue("@Id", userId);
}
```

### <font color="#ffff00">Пересечения таблиц</font>

1. **INNER JOIN** - только те строки, которые имеют совпадения в обеих таблицах.
2. **LEFT JOIN (LEFT OUTER JOIN)** - все строки из левой таблицы и совпадающие строки из правой таблицы. Если совпадений нет, возвращаются `NULL` значения из правой таблицы.
3. **RIGHT JOIN (RIGHT OUTER JOIN)** - все строки из правой таблицы и совпадающие строки из левой таблицы. Если совпадений нет, возвращаются `NULL` значения из левой таблицы.
4. **FULL JOIN (FULL OUTER JOIN)** - все строки из обеих таблиц. Если совпадений нет, возвращаются `NULL` значения из той таблицы, где совпадений не найдено.
5. **CROSS JOIN** - декартово произведение двух таблиц, т.е. все возможные комбинации строк из обеих таблиц.
6. **INTERSECT** - общие строки, найденные в обеих выборках. Не поддерживается в MySQL, но доступен в других СУБД.

### <font color="#ffff00">Индексы</font>

**Индекс** — это **пара ключ-значение** (ключ - код запроса, значение - номера строк).
Столбцы для индексации выбираем по частоте упоминания в WHERE.
**Составной индекс** - Для параллельно используемых в условиях столбцов. Формируется конкатенированный ключ одного из типов.

![](heap/_files/Pasted%20image%2020250210110354.png)

Типы индексов:
1) **B-дерево (b-tree index)** - Для *упорядоченных* данных. При поиске данных дерево просматривается до листового узла с ключем и указателем на соответствующие строки.

2) **Хэш-индексы (hash index)** - Для поиска по *точным совпадениям*. Поисковый запрос проходит через хэш-функцию, получая на выходе ключ для хэш-таблицы индексов.

3) **Индексы битовой карты (bitmap index)** - Для столбцов с *несколькими уникальными значениями* и *сложными запросами* к ним. Биты каждой карты показывают наличие признака в той или иной строке.

### <font color="#ffff00">Динамический SQL</font>

**Динамический SQL** — это SQL-код, формируемый и выполняемый во время выполнения программы, например, через `EXEC` или `sp_executesql`.
Удобен для гибких запросов, но несет риск SQL-инъекций и не позволяет кешировать планы выполнения.

```sql
DECLARE @TableName NVARCHAR(50) = 'Users';
DECLARE @Sql NVARCHAR(MAX) = 'SELECT * FROM ' + @TableName;
EXEC sp_executesql @Sql;
```

### <font color="#ffff00">Статистика</font>

В СУБД **статистика** — метаданные распределения значений в столбцах таблицы. 
Она помогает оптимизатору запросов выбирать наилучший план выполнения.

📊 **Что включает:**
- Гистограмму — разбивку значений столбца на диапазоны с указанием количества строк в каждом;
- Частоту повторяющихся значений (density);
- Общее количество строк и количество различных значений.

🔍 **Для чего используется:** 
Оптимизатор запросов на основе статистики оценивает, сколько строк будет возвращено при фильтрации, соединении или агрегации. 
Это напрямую влияет на выбор: сканировать всю таблицу, использовать индекс, каким способом выполнять `JOIN` и т.д.

⚙️ **Когда обновляется:**
- Автоматически при значительных изменениях в данных (если включена опция `AUTO_UPDATE_STATISTICS`);
- Явно вручную с помощью `UPDATE STATISTICS` или `sp_updatestats`.

📌 Пример создания статистики вручную:
```sql
CREATE STATISTICS Stat_Column1 ON MyTable (Column1);
```


### <font color="#ffff00">План запроса</font>

**План выполнения запроса** — это инструкция, которую СУБД составляет для выполнения SQL-запроса. 
Он показывает, как именно будет получен результат: какие таблицы будут задействованы, какие индексы использованы, в каком порядке и какими методами (например, сканирование, поиск, соединение и т. д.).

🧠 **Как работает:**
1. Оптимизатор анализирует запрос.
2. На основе статистики и метаданных подбирает наилучшую стратегию.
3. Создает план выполнения (execution plan), по которому запрос будет выполняться.

📄 **Что содержит план:**
- Операции (например, `Index Seek`, `Table Scan`, `Nested Loops`, `Hash Match`);
- Порядок выполнения операций (снизу вверх в графическом плане);
- Оценки количества строк и затрат (`Estimated Rows`, `Estimated Cost`);
- Выбор индексов;
- Предупреждения (например, о неиспользуемых индексах или преобразовании типов).

🔧 **Виды планов:**
- **Оценочный (Estimated Execution Plan)** — показывает, как запрос будет выполняться, без фактического запуска.
- **Фактический (Actual Execution Plan)** — отображает реальное выполнение запроса, включая фактическое число строк и ресурсы.

📌 **Как посмотреть:**
```sql
-- Включить оценочный план
SET SHOWPLAN_ALL ON;
GO
-- или через SSMS: кнопка "Display Estimated Execution Plan"

-- Включить фактический план
SET STATISTICS PROFILE ON;
GO
-- или: "Include Actual Execution Plan"
```