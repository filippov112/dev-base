 
# Поиск прыжками

**Поиск прыжками (Jump Search)** — это алгоритм поиска, который работает быстрее линейного поиска, если данные **отсортированы**. Вместо проверки каждого элемента алгоритм делает "прыжки" по массиву на фиксированное количество шагов, а затем выполняет линейный поиск в небольшом диапазоне.

### **Пример**

Допустим, есть **отсортированный** массив:  
`[1, 3, 5, 7, 9, 11, 13, 15, 17]`  
Нужно найти число `13`.

1. Выбираем шаг (например, `√9 = 3`).
2. Двигаемся по массиву с шагом `3`:
    - Первый прыжок (`1 → 7`) — `7` меньше `13`, идём дальше.
    - Второй прыжок (`7 → 13`) — нашли `13`, завершаем поиск.

Если при очередном прыжке число становится больше искомого, то выполняем **линейный поиск** в предыдущем блоке.

### **Сложность**

— В среднем — O(√n).  
— В лучшем случае (если сразу попали) — O(1).  
— В худшем (если число в конце) — O(√n).

### **Реализация на C#**

```csharp
using System;

class Program
{
    // Функция поиска прыжками
    static int JumpSearch(int[] array, int target)
    {
        int n = array.Length;
        int step = (int)Math.Floor(Math.Sqrt(n)); // Определяем размер прыжка
        int prev = 0;

        // Двигаемся прыжками, пока не найдём блок, где может быть элемент
        while (array[Math.Min(step, n) - 1] < target)
        {
            prev = step;
            step += (int)Math.Floor(Math.Sqrt(n));

            if (prev >= n) // Достигли конца массива
                return -1;
        }

        // Линейный поиск в найденном блоке
        for (int i = prev; i < Math.Min(step, n); i++)
        {
            if (array[i] == target)
                return i;
        }

        return -1; // Если элемент не найден
    }

    static void Main()
    {
        int[] numbers = { 1, 3, 5, 7, 9, 11, 13, 15, 17 };
        int target = 13;

        int index = JumpSearch(numbers, target);

        if (index != -1)
            Console.WriteLine($"Число {target} найдено в позиции {index}");
        else
            Console.WriteLine($"Число {target} не найдено");
    }
}
```

Алгоритм прыгает по массиву большими шагами, а затем выполняет линейный поиск в найденном диапазоне. Это делает его эффективнее линейного поиска, если массив отсортирован.

### Outer links:

