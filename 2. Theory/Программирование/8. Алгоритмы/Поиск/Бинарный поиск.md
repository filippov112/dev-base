#theory #theory-dev
 
---
**Бинарный поиск** — это быстрый алгоритм поиска элемента в **отсортированном** массиве. Он работает по принципу деления массива пополам: сравнивает искомый элемент с серединой и исключает половину элементов, в которой точно нет нужного значения.

### **Пример**

Допустим, есть отсортированный массив:  
`[2, 3, 5, 7, 8, 10, 12]`  
Нужно найти число `7`.

1. Берём середину массива: `7` (на позиции 3).
2. Искомое число `7` совпадает с серединой. Алгоритм завершается.

Если бы мы искали `8`, то:  
— Берём середину (`7`), но `8` больше, значит, нужный элемент находится **справа**.  
— Оставляем только `[8, 10, 12]` и повторяем процесс.

### **Сложность**

Алгоритм делит количество элементов пополам на каждом шаге.  
— В худшем случае — O(log n).  
— В лучшем (если сразу найден) — O(1).

### **Реализация на C#**

Программа принимает отсортированный массив и ищет число, возвращая его индекс или `-1`, если не найден.

```csharp
using System;

class Program
{
    // Функция бинарного поиска
    static int BinarySearch(int[] array, int target)
    {
        int left = 0, right = array.Length - 1;

        while (left <= right)
        {
            int mid = left + (right - left) / 2;

            if (array[mid] == target)
                return mid; // Найдено

            if (array[mid] < target)
                left = mid + 1; // Ищем справа
            else
                right = mid - 1; // Ищем слева
        }

        return -1; // Не найдено
    }

    static void Main()
    {
        int[] numbers = { 2, 3, 5, 7, 8, 10, 12 };
        int target = 7;

        int index = BinarySearch(numbers, target);

        if (index != -1)
            Console.WriteLine($"Число {target} найдено в позиции {index}");
        else
            Console.WriteLine($"Число {target} не найдено");
    }
}
```

Этот код делит массив на части и проверяет середину, пока не найдёт искомый элемент или не убедится, что его нет.

### Outer links:

