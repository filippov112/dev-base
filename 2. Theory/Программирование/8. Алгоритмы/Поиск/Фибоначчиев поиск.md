#theory #theory-dev
 
---
**Фибоначчиев поиск** — это алгоритм поиска элемента в отсортированном массиве, который использует числа Фибоначчи для выбора позиций, где нужно искать. Он работает по принципу деления массива на части, но делает это не равномерно, как бинарный поиск, а с помощью чисел Фибоначчи.

### **Пример**

Допустим, есть отсортированный массив:  
`[1, 3, 7, 10, 14, 18, 21, 25, 30]`  
Ищем число `14`.

1. Определяем ближайшее число Фибоначчи, большее или равное размеру массива. Здесь `F(6) = 13`.
2. Разделяем массив по индексу `F(4) = 5` (значение `18`).
3. `14` меньше `18`, поэтому ищем в левой части `[1, 3, 7, 10, 14]`.
4. Новая граница — `F(3) = 3` (значение `7`).
5. `14` больше `7`, поэтому ищем в правой части `[10, 14]`.
6. Новая граница — `F(2) = 2` (значение `10`).
7. `14` больше `10`, сдвигаем границу.
8. Проверяем `14`, совпадение найдено.

### **Сложность**

— В среднем и в худшем случае — O(log n), как у бинарного поиска, но без случайного доступа к памяти.

### **Реализация на C#**

```csharp
using System;

class Program
{
    // Функция Фибоначчиева поиска
    static int FibonacciSearch(int[] array, int target)
    {
        int fibM2 = 0; // (k-2)-е число Фибоначчи
        int fibM1 = 1; // (k-1)-е число Фибоначчи
        int fibM = fibM1 + fibM2; // k-е число Фибоначчи

        while (fibM < array.Length)
        {
            fibM2 = fibM1;
            fibM1 = fibM;
            fibM = fibM1 + fibM2;
        }

        int offset = -1;

        while (fibM > 1)
        {
            int i = Math.Min(offset + fibM2, array.Length - 1);

            if (array[i] < target)
            {
                fibM = fibM1;
                fibM1 = fibM2;
                fibM2 = fibM - fibM1;
                offset = i;
            }
            else if (array[i] > target)
            {
                fibM = fibM2;
                fibM1 -= fibM2;
                fibM2 = fibM - fibM1;
            }
            else
            {
                return i;
            }
        }

        if (fibM1 == 1 && array[offset + 1] == target)
            return offset + 1;

        return -1;
    }

    static void Main()
    {
        int[] numbers = { 1, 3, 7, 10, 14, 18, 21, 25, 30 };
        int target = 14;

        int index = FibonacciSearch(numbers, target);

        if (index != -1)
            Console.WriteLine($"Число {target} найдено в позиции {index}");
        else
            Console.WriteLine($"Число {target} не найдено");
    }
}
```

Этот алгоритм использует числа Фибоначчи для оптимального выбора позиций поиска.

### Outer links:

