# Архитектурные паттерны

1. **Монолитная архитектура** — вся система разрабатывается как единое приложение, без разделения на независимые части.
2. **Микросервисная архитектура** — система делится на небольшие независимые сервисы, которые взаимодействуют друг с другом через API или сообщения.
3. **Сервис-ориентированная архитектура (SOA)** — система состоит из сервисов, которые могут быть автономными и взаимодействовать через общую шину (ESB).
4. **Слойная архитектура (Layered Architecture)** — разделение приложения на слои (например, UI, бизнес-логика, данные), где каждый слой отвечает за свою задачу.
5. **Чистая архитектура (Clean Architecture)** — архитектура, в которой бизнес-логика отделена от деталей реализации (UI, базы данных, фреймворков) с помощью слоёв.
6. **Гексагональная архитектура (Hexagonal Architecture)** — разделяет бизнес-логику от внешних интерфейсов, используя порты и адаптеры.
7. **Onion Architecture** — основана на идее концентрических слоёв, где ядро системы (бизнес-логика) не зависит от внешних слоёв.
8. **Event-Driven Architecture (EDA)** — система, в которой компоненты взаимодействуют через события (например, брокеры сообщений).
9. **Client-Server** — разделение системы на две части: клиентскую, которая запрашивает данные, и серверную, которая их обрабатывает.
10. **MVC (Model-View-Controller)** — разделение на три компонента: модель (данные), представление (UI) и контроллер (управление логикой).
11. **MVVM (Model-View-ViewModel)** — похож на MVC, но с акцентом на привязку данных между моделью и представлением через ViewModel.
12. **CQRS (Command Query Responsibility Segregation)** — разделение операций команд (изменений) и запросов (чтения) для оптимизации.
13. **Event Sourcing** — хранение данных в виде последовательности событий, а не их текущего состояния.
14. **API Gateway** — единая точка входа для всех запросов, которая маршрутизирует их к нужным сервисам.
15. **Database per Service** — каждый микросервис использует свою собственную базу данных для обеспечения независимости.
16. **Proxy Pattern** — использование промежуточного объекта (прокси) для доступа к оригинальному объекту, добавляя дополнительную логику (например, кеширование, безопасность).
17. **Circuit Breaker** — паттерн для предотвращения каскадных сбоев, блокируя попытки обращения к сервису при его сбое.

MV-паттерны (Model-View) представляют собой различные способы организации пользовательского интерфейса и бизнес-логики. Вот основные из них:

- **MVC (Model-View-Controller)** — классический паттерн, где `Model` отвечает за данные, `View` за отображение, а `Controller` за обработку пользовательских действий.
- **MVP (Model-View-Presenter)** — `Presenter` заменяет `Controller`, он получает данные от `Model` и напрямую управляет `View`, обеспечивая лучшую тестируемость.
- **MVVM (Model-View-ViewModel)** — `ViewModel` связывает `Model` и `View`, обеспечивая двустороннюю привязку данных (binding), что удобно в реактивных фреймворках.
- **MVI (Model-View-Intent)** — используется в реактивных архитектурах, где `Intent` управляет потоком данных между `Model` и `View`.
- **PM (Presentation Model)** — аналог MVVM, но без привязки данных, `Presentation Model` отделяет логику представления от UI.

Эти паттерны решают схожие задачи, но различаются подходами к взаимодействию компонентов.