#theory #theory-ml
 
---
**Раскраска изображений** (из градаций серого в цветное) с помощью СНС.  
Чтобы СНС раскрасила черно-белое изображение, на ее выходе должно формироваться три цветовых канала - RGB.  
Но это не лучшее решение. Полноцветные изображения в данной задаче удобнее представлять в другом цветовом пространстве, например:

- **Lab:** (Light – слой яркости (0-100) (градации серого); a, b – цветовые слои (-128 - +127))

В этом случае СНС достаточно сгенерировать только для канала: a и b, вместо трех RGB.

---

### 1. Импортируем модули для преобразования форматов изображения

(Смысл модулей очевиден из названий)

```python
from skimage.color import rgb2lab, lab2rgb
```

---

### В качестве тестовой реализации мы можем:

- Взять любое полноцветное изображение
- Из него получить яркостную компоненту L (в градациях серого) и две цветовые компоненты a и b.
- На вход сети подадим изображение в градациях серого
- А на выходе потребуем цветовые составляющие a и b:

---

### 2. Загрузим изображение

```python
img = Image.open('image.rgb')
```

---

### 3. Для преобразования в пространство Lab определим следующую функцию

```python
def processed_image(img):
    image = img.resize((256, 256), Image.BILINEAR)  # стандартизируем размер
    image = np.array(image, dtype=float)            # преобразуем изображение в массив numpy
    size = image.shape                              # сохраняем текущий размер матрицы
    lab = rgb2lab(1.0/255 * image)                  # на вход функции нужно передавать изображение с компонентами RGB 
                                                    # и вещественными значениями пикселей от 0 до 1
    X, Y = lab[:, :, 0], lab[:, :, 1:]              # сохраняем x-light, y-(a,b)
    
    Y /= 128                                        # нормируем выходные значение в диапазон от -1 до 1
    X = X.reshape(1, size[0], size[1], 1)           # добавляем оси для батча(asix0) и цветовых каналов(вход-light-1, выход-ab-2)
    Y = Y.reshape(1, size[0], size[1], 2)
    return X, Y, size

X, Y, size = processed_image(img)
```

---

### 4. Пропишем структуру сети

```python
from keras.layers import Conv2D, UpSampling2D, InputLayer
from keras.models import Sequential

model = Sequential()
model.add(InputLayer(input_shape=(None, None, 1)))  # на вход подаем 2 мерную матрицу(ось z = 1)
model.add(Conv2D(64, (3, 3), activation='relu', padding='same'))
model.add(Conv2D(64, (3, 3), activation='relu', padding='same', strides=2))
model.add(Conv2D(128, (3, 3), activation='relu', padding='same'))
model.add(Conv2D(128, (3, 3), activation='relu', padding='same', strides=2))
model.add(Conv2D(256, (3, 3), activation='relu', padding='same'))
model.add(Conv2D(256, (3, 3), activation='relu', padding='same', strides=2))  # с помощью страйдов(пропусков пикселей) уменьшаем постепенно масштаб в 2**3 раза
model.add(Conv2D(512, (3, 3), activation='relu', padding='same'))
model.add(Conv2D(256, (3, 3), activation='relu', padding='same'))
model.add(Conv2D(128, (3, 3), activation='relu', padding='same'))
model.add(UpSampling2D((2, 2)))
model.add(Conv2D(64, (3, 3), activation='relu', padding='same'))
model.add(UpSampling2D((2, 2)))
model.add(Conv2D(32, (3, 3), activation='relu', padding='same'))
model.add(Conv2D(2, (3, 3), activation='tanh', padding='same'))  # на выходе получаем представление из 2 карт признаков a и b.
model.add(UpSampling2D((2, 2)))  # через UpSampling увеличиваем масштаб изображения в те же 2**3 раза.
                                 # UpSampling умножает пиксели(так здесь из 1 делает 2х2)
```

В качестве функции активации выбираем гиперболический тангенс, чтобы цветовые составляющие имели диапазон [-1; 1].

---

### 5. Обучим эту НС на одном изображении

Потребуем, чтобы она выдавала строго определенные выходные цветовые компоненты:

```python
model.compile(optimizer='adam', loss='mse')
model.fit(x=X, y=Y, batch_size=1, epochs=50)
```

---

### 6. После обучения прогоним через сеть изображение в градациях серого

```python
output = model.predict(X)

# Посмотрим на результат
output *= 128  # возвращаемся к диапазону [-128 - +127]
min_vals, max_vals = -128, 127
ab = np.clip(output[0], min_vals, max_vals)  # обрезаем завышения допустимого диапазона

cur = np.zeros((size[0], size[1], 3))  # создаем заготовку изображения(матрицу с размерами size по пикселям, и 3 слоя в глубину)
cur[:, :, 0] = np.clip(X[0][:, :, 0], 0, 100)  # заполняем 1ый слой исходным слоем яркости(зачем-то опять обрезаем края которых там и нет)
cur[:, :, 1:] = ab  # заполняем 2ой и 3ий слои нашим подогнанным по диапазону тензором из 2 карт признаков.

plt.subplot(1, 2, 1)
plt.imshow(img)
plt.subplot(1, 2, 2)
plt.imshow(lab2rgb(cur))  # выводим изображение в консоль
```

[16.1. Код программы](2.%20Theory/Машинное%20обучение/Сверточные%20нейронные%20сети/16.1.%20Код%20программы.md)