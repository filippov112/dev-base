#theory #theory-ml
 
---
#### Подключим нейронку без полносвязных слоев в конце.

```python
vgg = keras.applications.vgg19.VGG19(include_top=False, weights='imagenet')  # Отключаем последние слои, используем веса ImageNet
vgg.trainable = False  # Запрещаем тренировку
```

В дальнейшем нам нужно будет работать с этой сетью, подавать на ее вход изображения и брать на выходах определенных слоев вычисленные карты признаков:

#### Выделим из сети нужные слои для получения тензоров

```python
print(vgg.summary())  # Вывод структуры нейронной сети в консоль

content_layers = ['block5_conv2']  # Для контента
style_layers = ['block1_conv1',  # Для стиля
                'block2_conv1',
                'block3_conv1',
                'block4_conv1',
                'block5_conv1'
               ]

num_content_layers = len(content_layers)
num_style_layers = len(style_layers)

style_outputs = [vgg.get_layer(name).output for name in style_layers]
content_outputs = [vgg.get_layer(name).output for name in content_layers]
```

#### Формируем копию VGG-19 через Model

```python
model_outputs = style_outputs + content_outputs

model = keras.models.Model(vgg.input, model_outputs)  # Создаем модель, используя вход из vgg и выходы из созданных списков

for layer in model.layers:
    layer.trainable = False  # Отключаем тренировку слоев модели

print(model.summary())  # Вывод структуры модели в консоль
```

Пропуская через нее какое-либо изображение, будем получать тензор выходных значений в соответствии со списком `model_outputs`.

Например:
```python
outs = model(x_img)
```
Это даст значения выходных карт признаков со всех шести слоев: `block1_conv1`, `block2_conv1`, `block3_conv1`, `block4_conv1`, `block5_conv1`, `block5_conv2`.
