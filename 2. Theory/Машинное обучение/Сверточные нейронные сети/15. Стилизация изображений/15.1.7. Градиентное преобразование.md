#theory #theory-ml
 
---
```python
for i in range(num_iterations):
    # Пробегаем по алгоритму заданные 100 раз

    with tf.GradientTape() as tape:
        # Записываем все величины на каждом нейроне сети в момент прогонки изображения
        all_loss = compute_loss(**cfg)
        
    # Разделяем показатели качества по группам (общий, стиля, контента)
    loss, style_score, content_score = all_loss
    
    # Вычисляем градиенты относительно пикселей изображения и вычисленных производных
    grads = tape.gradient(loss, init_image)
    
    # Применяем градиенты к пикселям стилизованных котиков
    opt.apply_gradients([(grads, init_image)])
    
    # Усекаем цвета в рамках 1 байта - константа изображения до обратного преобразования
    clipped = tf.clip_by_value(init_image, min_vals, max_vals)
    init_image.assign(clipped)
    
    # Отбираем изображение с минимальными потерями
    if loss < best_loss:
        best_loss = loss  # Сохраняем потери
        best_img = deprocess_img(init_image.numpy())  # Обратно преобразуем и сохраняем лучшее изображение
        
        plot_img = deprocess_img(init_image.numpy())
        imgs.append(plot_img)  # Создаем его копию для общей коллекции с уменьшением потерь
        
        print('Iteration: {}'.format(i))  # Выводим номер итерации

```