#lang #lang-unity 

---
[Официальная документация Zenject](https://github.com/modesttree/Zenject)

**Zenject** — это фреймворк для *Dependency Injection (DI)* в Unity, который помогает управлять зависимостями объектов и упрощает тестирование и масштабирование приложений.

#### Основные понятия

1. **Dependency Injection (DI)** - Паттерн проектирования, подразумевающий внедрение сервисов в клиенты на уровне интерфейса.
	- *Классы Сервисы* - выполняют простые задачи (в основном это различные службы вроде ввода, хранилища и т.п.)
	- *Классы Клиенты* - выполняют сложные специфические задачи и нуждаются в сервисах (основные элементы игры: враги, игрок, и т.п.)
	- *Классы Injector* - внедряют сервисы в клиенты
2. **Container**: Контейнер Zenject, который управляет созданием и жизненным циклом объектов.
3. **Binding**: Процесс связывания зависимостей и реализаций.

#### Основные компоненты

1. **Context**:  Умное окружение, *DI-контейнер* правил разрешения зависимостей в определенной области игры.
   - `SceneContext`: Для настройки зависимостей на уровне сцены. 
	   - // создается на объекте в сцене. Запускается сразу (Auto Run) или по команде.
   - `ProjectContext`: Для глобальных зависимостей в проекте. 
	   - // SO. создается в папке Resources со SO-installers, после чего добавляется **<font color="#ff0000">SceneContext</font>**-ом в DDOL. Не работает без SceneContext.
   - `GameObjectContext`: В рамках одного объекта. 
	   - // создается на конкретном объекте.
   - `DecoratorContext`: Декоратор для контекста сцены, для использования одного контекста в нескольких однотипных сценах

Для переброски зависимостей между несколькими параллельными контекстами можно использовать *Contract Names*.


2. **Installer**: *Класс-Injector*, используемый для проброски *связей* (Bindings) в контексты. 
Установщики подразделяются на:
- `SO-Installers` - для контекстов проекта.
- `Mono Installers` - для контекстов сцен.
- `Prefab Installers` - для контекстов сцены с возможностью сохранения в префабы.

Типы связей:
   - `Transient`: Новый экземпляр на каждый запрос связи.
   - `Singleton`: Один экземпляр на связь.
   - `Cached`: Несколько экземпляров на связь.

#### Способы внедрения зависимостей

![|700](heap/_files/Unity/Pasted%20image%2020240821193837.png)
1. **Через конструктор** - основной способ для обычных классов.
2. **Через поля/свойства** - лучше отказаться, поскольку возникает жесткая зависимость от Zenject-а.
3. **Через метод** - если внедряем в *MonoBehaviour*.

Если от объекта не требуется явное наличие в сцене, а от *MB*  требуется только базовое поведение, то его можно иммитировать интерфейсами Zenject.
После чего можно будет пробрасывать зависимости **через конструктор**.

- *Start()* - **IInitializable**
- *Update()* - **ITickable**
- *FixedUpdate()* - **IFixedTickable**
- *LateUpdate()* - **ILateTickable**
- *Destroy()* - **IDisposable**


> Полный список вариантов инициализации связи можно посмотреть в `Util/CheatSheet.cs`.

```csharp

// Mono Installer
public class GameInstaller : MonoInstaller
{
	[SerializeField]
	private Enemy enemy;
	
	public override void InstallBindings()
	{
	   Container // Точка доступа контекста к которому привязан инсталлер
		   .Bind<IEnemy>() // Указываем интерфейс/класс для которого хотим задать реализацию в рамках контекста.
		   .To<Enemy>() // Определяем какой класс будем использовать в качестве реализации интерфейса
		   .FromInstance(enemy) // Указываем образец, откуда будем брать зависимости при создании экземпляров
		   // To и From - взаимозаменяемы (можно указать только класс, только шаблон, или и то и другое).
		   .AsTransient(); // Определяем тип действия связи
		   // .NonLazy(); - определяет когда будет инициализироваться экземпляр (по-умолчанию при первом запросе, с NonLazy - сразу при запуске контекста с инсталлерами)
		   // .WithArguments(a, b, ...); - если у конструктора есть еще аргументы, которых нет ни в одном контексте.
		   // .QueueForInject(enemy); - добавляет экземпляр в очередь на немедленную привязку ко всем точкам инъекции, без необходимости запроса с их стороны. (дополняет собой NonLazy, который отвечает только за инициализацию самого экземпляра)
	}
}
```

```csharp
// SO Installer
[CreateAssetMenu(fileName = "GameSettingsInstaller", menuName = "Installers/GameSettingsInstaller")]
public class GameSettingsInstaller : ScriptableObjectInstaller
{
   public GameSettings gameSettings;

   public override void InstallBindings()
   {
		Container.BindInstance(gameSettings).AsSingle();

		Container.Bind<Enemy>().FromComponentInHierarchy().AsSingle(); // FCIH - ищет экземпляр среди всех объектов в пределах контекста инсталлера
	   // .FromComponentInNewPrefab(enemy) - ограничиваем поиск префабом частью которого является enemy
   }
}
```

```csharp
// Инъекции
public class Player : MonoBehaviour
{
   [Inject] // через поле
   private IWeapon _weapon;

	private IWeapon weapon2;

	[Inject] // через метод (В момент запуска DI-контейнер запускает все методы инъекций которые может найти)
	public void Construct(IWeapon _w)
	{
		weapon2 = _w;
	}
}


```

### Важное правило при переходе на Zenject

> Все инстансы зависящих от Zenject префабов должны выполняться только через **DI-container**.

> [!note]  Вставка UI элементов должна производиться только в активный холст. Иначе пропадет отображение объекта!

1. Добавляем инъекцию ссылки на основной контейнер и через него выполняем инстанс.
	```csharp
	[Inject] private DiContainer diContainer;

	diContainer.InstantiatePrefab(prefabObject, position, rotation, parent);
	```

