#lang #lang-unity

---
**Корутины** (они же - **сопроцессы**) в Unity - это итераторы, каждый цикл итерации которых совпадает с 1 кадром игрового времени (не обязательно последовательных при этом, т.к. зависит от функции ожидания в операторе `yield`, если это не `null`.)

> [!warning]
> Корутины НЕ являются по-настоящему асинхронными. Они выполняются в том же потоке, что и отрисовка кадров.
> Для выполнения по-настоящему асинхронных задач, таких как сетевые запросы, используйте класс `AsyncOperation`.

Применяются для выполнения задач не зависящих от одного конкретного кадра.
То есть с помощью них можно растянуть выполнение длительной задачи на несколько кадров.

##### **Например...**
- **Анимация:** 
	Корутины отлично подходят для создания плавных анимаций, так как они позволяют точно контролировать время выполнения каждого шага анимации.
- **Задержка:** 
	Корутины можно использовать для задержки выполнения кода на определенное время или до тех пор, пока не произойдет какое-либо событие.
- **Работа с IEnumerator:** 
	Корутины можно использовать для работы с *функциями ожидания*, такими как WaitForSeconds и WaitForEndOfFrame.
- **Асинхронная загрузка:** 
	Корутины можно использовать для асинхронной загрузки ресурсов, таких как изображения, аудио и текстовые файлы.
- **Игровой процесс:** 
	Корутины можно использовать для реализации различных игровых механик, таких как системы частиц, искусственный интеллект и диалоги.
- **Визуальные эффекты:** 
	Корутины можно использовать для создания различных визуальных эффектов, таких как мерцание, пульсация и изменение цвета.


#### **Дополнительно**
- Можно заменять методы MonoBehaviour, которые не связаны с циклом кадров (как <font color="#ff0000">Update, Awake</font>) на IEnumarator, например <font color="#00b050">Start, OnCollision, OnTrigger, OnMouse</font>.
- Можно делать вложенные корутины, возвращая в `yield return StartCoroutine(...)`
- Можно написать свои *функции ожидания* наследуя `CustomYieldInstruction`.

#### **Синтаксис:**
`yield`  - приостановка выполнения кода и возврат управления Unity. (Существует несколько типов `yield`, которые позволяют приостановить выполнение **на определенное время**, дождаться завершения **события** или выполнить **асинхронную операцию**).
`IEnumerator` - объявление.
`StartCoroutine` - запуск.

```csharp
IEnumerator MoveObject(Vector3 targetPosition)
{
    while (Vector3.Distance(transform.position, targetPosition) > 0.01f)
    {
        transform.position = Vector3.MoveTowards(transform.position, targetPosition, speed * Time.deltaTime);
        yield return null; // Приостановить выполнение кода до следующего кадра
    }
}

...
StartCoroutine(MoveObject(new Vector3(10, 20, 30)));

Coroutine a = StartCoroutine(MoveObject(new Vector3(10, 20, 30)));

StopCoroutine(a);

StopAllCoroutines();

```

Еще пример:
```csharp
IEnumerator MyCoroutine()
{
    // Приостановить выполнение на 2 секунды
    yield return new WaitForSeconds(2.0f);

    // Выполнить действие
    print("Coroutine is running!");

    // Завершить корутину
    yield break;
}

public class Example : MonoBehaviour
{
    private void Start()
    {
        // Запустить корутину
        StartCoroutine(MyCoroutine());
    }

    private IEnumerator MyCoroutine()
    {
        // ...
    }
}

```

### Inner links:
[Итераторы](1.%20Languages/C-sharp/0.%20Введение/2.%20Функции/Итераторы.md)


### Outer links:


