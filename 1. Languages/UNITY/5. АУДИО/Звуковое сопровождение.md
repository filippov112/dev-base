 #lang #lang-unity

#### Способ реализации класса наследника для объектов, воспроизводящих звуки
```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

// Класс предок для всех объектов, на которых предполагается наличие звуков
public class Sounds : MonoBehaviour
{
    public AudioClip[] sounds; // Список звуков для конкретного потомка

    private AudioSource audioSrc => GetComponent<AudioSource>(); // у объекта должен иметься источник звука

 
    // Если требуется для одного типа действия содержать несколько случайных вариантов звуков 
    // Можно реализовать ВЛОЖЕННЫЙ МАССИВ для инспектора
    [SerializeField] SoundArrays[] randSounds;
    [System.Serializable]
    public class SoundArrays
    {
        public AudioClip[] soundArray;
        public int length() { return soundArray.Length; }

        public SoundArrays(AudioClip[] soundArray)
        {
            this.soundArray = soundArray;
        }
    }


    public void PlaySound(int i, float volume = 1f, bool destroyed = true, float p1 = 0.5f, float p2 = 0.5f, bool random = false)
    {
        AudioClip _sound = random ? randSounds[i].soundArray[Random.Range(0, randSounds[i].length())] : sounds[i];
        audioSrc.pitch = p1 == p2 ? p1 : Random.Range(p1, p2);
        if (destroyed)
        {
            // создает РАЗОВЫЙ источник звука на сцене, и удаляет его после воспроизведения
            AudioSource.PlayClipAtPoint(_sound, transform.position, volume); 
        } else
        {
            audioSrc.PlayOneShot(_sound, volume);
        }
        
    }
}
```