#lang #lang-unity 

Есть несколько возможных вариантов:

1. Для 2D
```csharp
Rigidbody rb;
void Start()
{
    rb = GetComponent<Rigidbody>();
}
// Метод первый подойдет для 2-мерных игр. XY камеры передается объекту, Z же остается константой.
private void OnMouseDrag()
{

    Vector3 mp_screen = new Vector3(Input.mousePosition.x, Input.mousePosition.y, -Camera.main.transform.position.z + transform.position.z);

    Vector3 block = Camera.main.ScreenToWorldPoint(mp_screen);

    transform.position = block;

    rb.isKinematic = true; // Нужно чтобы обнулять инерционные силы при захвате объекта
}

private void OnMouseUp()
{
    rb.isKinematic = false;
}

```

2. Для 3D
```csharp
Collider c;
Vector3 currentP;
Vector3 lastP;
//Start is called before the first frame update
void Start()
{
    c = GetComponent<Collider>();
}

private void OnMouseDown()
{
    c.enabled = false;
    Raycast(out lastP);
}

private void OnMouseDrag()
{
    Raycast(out currentP);
    transform.position += currentP - lastP;
    lastP = currentP;
}

private void OnMouseUp()
{
    lastP = currentP = Vector3.zero;
    c.enabled = true;
}


void Raycast(out Vector3 point)
{
    RaycastHit hit;
    point = transform.position;
    Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition - Input.mousePositionDelta);
    if (Physics.Raycast(ray, out hit, 1000.0f))
    {
        point = hit.point;
    }
}
```

3. Для UI
```csharp
public class drag : MonoBehaviour, IBeginDragHandler, IEndDragHandler, IDragHandler
{
	// Реализация аналогична предыдущему примеру
    public void OnDrag(PointerEventData eventData)
	{
	    throw new System.NotImplementedException();
	}
	
	public void OnEndDrag(PointerEventData eventData)
	{
	    throw new System.NotImplementedException();
	}
	
	public void OnBeginDrag(PointerEventData eventData)
	{
	    throw new System.NotImplementedException();
	}
}
```