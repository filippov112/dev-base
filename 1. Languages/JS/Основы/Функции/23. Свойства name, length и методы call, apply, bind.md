#lang #lang-js

# 23. Свойства name, length и методы call, apply, bind

**Первое:** у объекта-функции есть, по крайней мере, два встроенных свойства (которые **нельзя изменять**) – это **name** и **length**.

```javascript
function showMessage(msg) {
    console.log(showMessage.name);
}

let func = function (msg) {
    console.log(func.name);
}

let car = {
    go() {},
    stop: function() {}
};

console.log(car.go.name);
console.log(car.stop.name);
```

Функция не будет иметь свойства `name`, только если это анонимная функция, объявленная в **отдельном блоке** или **вызванная на месте**.

Следующее встроенное свойство **length** содержит количество параметров функции в её объявлении. Например:

```javascript
function func1(a) {}
function func2(a, b) {}
function other(a, b, ...more) {}

console.log(func1.length); // 1
console.log(func2.length); // 2
console.log(other.length);  // 2 - расширенные параметры не учитываются при подсчете
```

**Второй вопрос:** можно ли у функций создавать **свои свойства**? Ответ положительный. Например, объявим функцию:

```javascript
function funcCount() {
    console.log("вызов функции: " + ++funcCount.counter);
}

funcCount.counter = 0;
```

### Методы call и apply

Методы **call** и **apply** позволяют **вызывать функции** с указанием их **контекста выполнения** в соответствии с синтаксисом:

```javascript
func.call(context, arg1, arg2, ...)  
func.apply(context, args)
```

где **args** – это массив или массивоподобный объект.
Предположим, имеется объект:

```javascript
let car = {
    model: "mercedes",
    getModel(model) {
        if (model) console.log(model);
        else console.log(this.model);
    }
};
```

И мы определяем глобальную ссылку на его метод:

```javascript
let func = car.getModel;
```

Тогда, при его вызове получим ошибку:

```javascript
func();  // ошибка: потеря контекста выполнения
```

Это связано с **потерей контекста выполнения** этого метода: он начинает выполняться в глобальном контексте, в котором ссылка **this** равна `undefined`. Но, с помощью встроенного метода `call` это можно поправить:

```javascript
func.call(car);
func.call(car, "opel");
```

Здесь мы первым аргументом указываем верное значение `this=car`, и функция выполняется как задумано.

## Метод bind

Метод `bind` позволяет привязать контекст выполнения функции:

```javascript
let bound = func.bind(context, [arg1], [arg2], ...);
```

Он неявно **связывает контекст** (`this=context`) **до вызова самой функции**. Например, для нашего случая с `myMath` его можно использовать так:

```javascript
let sum = myMath.sum.bind(myMath);
console.log(sum(1, 2, 3, 4));
```

Или так…

```javascript
let sum = myMath.sum.bind(myMath, 1, 2);
console.log(sum(3, 4));
```

### Named Function Expression (NFE)

Использование function expression позволяет использовать имя функции в её собственном теле без потери мобильности её основного (внешнего) имени. Т.е. мы можем изменить имя переменной, к которой привязана функция, не редактируя при этом её внутренний код.

```javascript
let getName = function Name(name) {
    if (name) return name;
    else return Name("none");
};
```
