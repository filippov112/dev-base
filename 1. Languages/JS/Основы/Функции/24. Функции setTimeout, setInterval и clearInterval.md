#lang #lang-js

# 24. Функции setTimeout, setInterval и clearInterval

### **setTimeout - отложенный запуск функций**

1. Запуск таймеров выполняется после выполнения всего кода программы.
2. Таймеры запускаются все сразу, параллельно.
3. Можно прерывать таймер до его запуска: 

   ```javascript
   clearTimeout(idLoading);
   ```

#### Синтаксис

```javascript
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...);
```

- **func|code** – ссылка на функцию или строка кода, которая должна выполниться;
- **delay** – задержка перед вызовом в миллисекундах (1000 мс = 1 сек);
- **arg1, arg2, …** - возможные аргументы для запускаемой функции (не поддерживаются в старых браузерах IE9-).

### Пример использования

Запустим функцию через две секунды:

```javascript
function createMsg() {
    let msg = "Hello";
    console.log(msg);
}

setTimeout(createMsg, 2000, "timeout hello");
```

Можно прописывать конкретный код для запуска, но лучше использовать функции:

```javascript
setTimeout("alert('Привет')", 1000);
```

### **Функция setInterval – цикличный запуск с временным промежутком**

```javascript
function createClock(seconds) {
    let sec = seconds;
    return function() {
        sec++;
        console.log("Прошло " + sec + " секунд(а)");
    }
}

let clock = createClock(0);
let idClock = setInterval(clock, 1000); // можно запускать и без переменной, но она нужна для прерывания цикла
setTimeout(function() { clearInterval(idClock); }, 5000);
```

### **Потеря `this`**

Одной из проблем использования **setTimeout** и **setInterval** является потеря `this` при вызове **методов объектов**.
Исправить ситуацию можно несколькими способами:

1. Первый способ:
   ```javascript
   setTimeout(function() { car.showModel(); }, 1000);
   ```

2. Второй способ – использовать метод `bind`:
   ```javascript
   let show = car.showModel.bind(car);
   setTimeout(show, 1000);
   ```
