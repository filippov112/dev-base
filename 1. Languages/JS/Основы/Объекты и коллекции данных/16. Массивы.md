#JS

# 16. Массивы

### **Массивы (те же списки)**

```javascript
let ar = [];  // пустой массив
let ar = [1, 30, 0, -2]; // одномерный массив чисел
let ar = ["Яблоко", "Апельсин", "Слива"];

console.log(ar[0]);

ar[1] = 'Груша';
```

У массива есть свойство `length`, хранящее значение равное **максимальному индексу плюс один:** 

```javascript
Array.length = maxIndex + 1
```

```javascript
for (let i = 0; i < ar.length; ++i) {
    console.log(ar[i]);
}

console.log(ar); // можно и так вывести массив
```

1. **Обратите внимание, length – это не число элементов массива в привычном нам виде.** Например, если в наш массив добавить еще один элемент с большим индексом:

```javascript
ar[999] = 'Виноград';
```

то `length` будет равно 1000, но в массиве будет всего пять элементов:

- "Яблоко"
- "Груша"
- "Слива"
- "Лимон"
- "Виноград" (с индексом 999)

2. `length` можно задавать **вручную**, так можно обрезать длину массивов:

```javascript
let dig = [1, 2, 3, 4, 5];

dig.length = 3;

dig.length = 5;
```

И убедиться, что последние два элемента уже не существуют:

```javascript
console.log(dig);
```

3. У массивов имеется оптимизация для взаимодействия в нормальных условиях (последовательное заполнение и считывание элементов). Если заполнять массив с конца или давать произвольные ключи для элементов или определять дополнительные свойства как у объектов, то **оптимизация теряется.**

```javascript
let digits = [];

digits[99999] = 1;

digits.zero = null;

digits[100] = 100;

digits[99] = 99;
```

### **For of – цикл для массивов**

В отличие от стандартного `for in`, работает в 10-100 раз быстрее.
Работает только **на чтение, без записи, как и for in.**

```javascript
for (let value of fruits) {
    console.log(value);
}
```
