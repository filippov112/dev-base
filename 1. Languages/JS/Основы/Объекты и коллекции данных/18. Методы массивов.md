#lang #lang-js

# 18. Методы массивов

### **Splice - ножницы**

Метод `splice()` - умеет **добавлять, удалять и заменять** элементы. Он начинает с позиции **index**, удаляет **deleteCount** элементов и вставляет **elem1, ..., elemN** на их место. Возвращает массив из удалённых элементов.

```javascript
Array.splice(index[, deleteCount, elem1, ..., elemN])
```

Предположим, имеется массив:

```javascript
let ar = ["Я", "смотрю", "этот", "обучающий", "урок"];
```

Удалим 3-й и 4-й элементы «этот» и «обучающий»:

```javascript
ar.splice(2, 2);
```

### **Slice - срез**

Метод `slice()` возвращает массив, в который **копирует элементы**, начиная с индекса **start** и заканчивая индексом **end-1**.

```javascript
Array.slice([start], [end])
```

Например:

```javascript
let ar = ["Я", "смотрю", "этот", "обучающий", "урок"];
let res1 = ar.slice(2, 4);   // этот, обучающий
let res2 = ar.slice(3);      // обучающий, урок
let res3 = ar.slice(-3);     // этот, обучающий, урок
```

### **Concat - склейка**

Метод `concat()` возвращает новый массив, состоящий из элементов **текущего** массива, **плюс элементы**, указанные в качестве **аргументов**:

```javascript
Array.concat(arg1, arg2...)
```

Здесь `arg1`, `arg2` могут быть **как примитивными** данными (строки, числа), **так и массивами**. Например:

```javascript
let ar = [1, 2];
let res1 = ar.concat([3, 4]); // 1,2,3,4
console.log(res1);

let res2 = ar.concat([3, 4], [5, 6]); // 1,2,3,4,5,6 – списки раскрываются до примитивов, а объекты копируют ссылку в новый массив
console.log(res2);

console.log(ar.concat([3, 4], 5, 6)); // 1,2,3,4,5,6
```

### **ForEach – расширенный for**

Данный метод **перебирает элементы массива** и позволяет выполнить какие-либо действия с ними. Имеет следующий синтаксис:

```javascript
ar.forEach(function(item, index, array) {
  // ... делать что-то с item
});
```

А вот так все нечетные элементы можно заменить на 1:

```javascript
let ar = ["Я", "смотрю", "этот", "обучающий", "урок"];

ar.forEach((item, index, array) => {
  if (item % 2 != 0) array[index] = 1;
});
```

### **IndexOf, lastIndexOf и includes – поиск элементов**

Данные методы имеют одинаковый синтаксис и делают по сути одно и то же с небольшими отличиями. Их синтаксис следующий:

- `ar.indexOf(item, from)` ищет `item`, **начиная с индекса `from`**, и возвращает индекс, на котором был найден искомый элемент, в **противном случае -1**.
- `ar.lastIndexOf(item, from)` – то же самое, но ищет **справа налево**.
- `ar.includes(item, from)` – **аналог `in`**. Ищет `item`, начиная с индекса `from`, и возвращает `true`, если такой элемент был найден.

Например:

```javascript
let ar = ["Я", "смотрю", "этот", "обучающий", "урок", 0, false, null];

let res1 = ar.indexOf("смотрю", 0);        // 1
let res2 = ar.lastIndexOf(null, 0);         // -1
let res3 = ar.includes(0, 3);                // true
```

### **Find и findIndex – поиск 1 элемента и индекса соотв.**

Метод `find` позволяет найти элемент массива по какому-либо критерию (условию). Он имеет следующий синтаксис:

```javascript
let result = ar.find(function(item, index, array) {
  // если true – возвращается текущий элемент и перебор прерывается
  // если все итерации оказались ложными, возвращается undefined
});
```

```javascript
let res = cars.find(item => item.price < 1000);
console.log(res);
```

### **Filter – просто фильтр**

Если нужно найти **все элементы по заданному критерию** (условию), то следует использовать метод `filter`:

```javascript
let results = ar.filter(function(item, index, array) {
  // если true – элемент добавляется к результату, и перебор продолжается
  // возвращается пустой массив в случае, если ничего не найдено
});
```

Перепишем наш пример:

```javascript
let res = cars.filter(item => item.price <= 1000);
```

### **Map – обычный map**

Позволяет обрабатывать элементы массива:

```javascript
let result = arr.map(function(item, index, array) {
  // возвращается новое значение вместо элемента
});
```

И может быть использован так:

```javascript
let cars = ["toyota", "opel", "reno"];
let res = cars.map(function(item) {
  return item.length;
});
```

### **Reverse - разворот**

Данный метод прост: он **меняет порядок** следования элементов на обратный. Например:

```javascript
let dig = [4, 25, 2, 1];
dig.reverse();
// Получим этот же массив со значениями: 1, 2, 25, 4.
```

### **Sort - сортировка**

Данный метод **сортирует** массив по тому критерию, который указывается в её **необязательной** callback-функции:

```javascript
ar.sort(function(a, b) {
  if (a > b) return 1; // если первое больше второго // **по возрастанию**
  if (a == b) return 0; // если равны
  if (a < b) return -1; // если первое значение меньше второго
});
```

1. Сортировка **выполняется непосредственно внутри массива `ar`,** но функция **также и возвращает отсортированный массив**, правда это возвращаемое значение, обычно игнорируется. Например:

```javascript
let dig = [4, 25, 2];
dig.sort();
console.log(dig);
```

2. **По умолчанию** `sort` рассматривает значения элементов массива **как строки** и сортирует их в **лексикографическом порядке**. Для указания другого критерия сортировки, мы должны записать свою callback-функцию:

```javascript
dig.sort(function(a, b) {
  if (a > b) return 1;
  else if (a < b) return -1;
  else return 0;
});
```

3. callback-функция **не обязательно** должна возвращать именно 1 и -1; можно вернуть любое положительное, если `a > b`, и отрицательное при `a < b`.

```javascript
dig.sort((a, b) => a - b);
```

### **Split, join – обычные split и join**

Применяются к строкам:

```javascript
let emailsTo = "alex12@m.ru; m2@m.com; pp@g.com; upr@g.ru";
let arEmails = emailsTo.split("; ");
let strEmails = arEmails.join(", ");
console.log(strEmails);
```

У **split** есть второй необязательный аргумент, указывающий максимальное число элементов в выходном массиве.

```javascript
let arEmails = emailsTo.split("; ", 2);
```

### **Reduce и reduceRight - агрегаторы**

Методы **reduce** и **reduceRight**, как правило, используются для вычисления какого-нибудь **единого значения** на основе всего массива. **reduceRight** работает по массиву справа налево.

```javascript
let value = ar.reduce(function(previousValue, item, index, array) {
  // ...
}, [initial]);
```

- **previousValue** – результат предыдущего вызова этой функции, равен **initial** при первом вызове (если передан `initial`).

Например, сумма значений элементов массива:

```javascript
let digs = [1, -2, 100, 3, 9, 54];
let sum = digs.reduce((sum, current) => sum + current, 0);
console.log(sum);
```

Если начальное значение не указано, то в качестве `previousValue` берется первый элемент массива, и функция стартует сразу со второго элемента. Но такое использование требует **крайней осторожности**.

### **Array.isArray – массив?**

Массивы не образуют отдельный тип языка. Они основаны на объектах. Поэтому `typeof` не может отличить простой объект от массива:

```javascript
console.log(typeof {}); // object
console.log(typeof []);  // тоже object
```

Он возвращает `true`, если `value` массив, и `false