#lang #lang-js

# 21. Коллекции map и set (карты и наборы)

**Map - словари из любых пар (ключ-значение)**

В отличие от объектов, в **Map** в качестве ключа могут выступать не только строки, но и **любые типы данных**.

У **Map** есть такие методы и свойства:

- `new Map()` – создаёт коллекцию;
- `map.set(key, value)` – записывает по ключу `key` значение `value`;
- `map.get(key)` – возвращает значение по ключу или `undefined`, если ключ `key` отсутствует;
- `map.has(key)` – возвращает `true`, если ключ `key` присутствует в коллекции, иначе `false`;
- `map.delete(key)` – удаляет элемент по ключу `key`;
- `map.clear()` – очищает коллекцию от всех элементов;
- `map.size` – возвращает текущее количество элементов.

```javascript
let m = new Map();
m.set("string", "строка");
console.log(m.get("string"));
```

**Ключи могут быть объектами**

```javascript
let user = {
    name: "JavaScript",
    type: "ES6"
};

let m = new Map();
m.set(user, "объект user");
```

**Можно напрямую преобразовывать массивы из пар-массивов в карту**

```javascript
let car = new Map([
    ["model", "opel"],
    ["color", 0xff],
    ["price", 1000]
]);
```

Объект **Map** можно создать на основе любого итерируемого объекта, представляющего данные в формате «ключ - значение». Например, можно взять некий объект:

```javascript
let book = {
    author: "Пушкин",
    title: "Онегин",
    pages: 100,
    price: 80
};

let lib = new Map(Object.entries(book));
```

**`.entries(object)` и `.fromEntries(array)`** - первый формирует двумерный массив ключ-значение из объектов, а второй, соответственно, наоборот.

Карты можно перебирать через `for` (порядок соответствует очередности добавления элементов). Как и словари в Python, карты поддерживают перебор через `.keys()` и `.values()`.
Также карты поддерживают перебор и через `forEach`:

```javascript
Map.forEach(function(value, key, map) {
    // что-то делаем
});
```

**Set - обычное множество (здесь набор)**

Данный объект имеет следующие методы и свойства:
- `new Set(iterable)` – создаёт **Set**. Если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в **Set**;
- `set.add(value)` – добавляет значение (если оно уже есть, то ничего не происходит), возвращает тот же объект **set**;
- `set.delete(value)` – удаляет значение, возвращает `true`, если `value` было найдено и удалено, иначе `false`;
- `set.has(value)` – возвращает `true`, если значение присутствует в коллекции, иначе `false`;
- `set.clear()` – удаляет все значения из набора;
- `set.size` – возвращает количество элементов в наборе.

```javascript
let m = new Set([1, 2, 4, 5]);
```

Перебрать объект **Set** также можно и с помощью встроенного метода `forEach`. Он имеет следующий синтаксис:

```javascript
Set.forEach(function(value, valueAgain, set) {
    // что-то делаем
});
```

Здесь второй аргумент `valueAgain` добавлен для синтаксической совместимости данного метода с аналогичным методом из **Map**.
