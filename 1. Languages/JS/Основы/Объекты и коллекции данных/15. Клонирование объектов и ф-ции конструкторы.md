#lang #lang-js

# 15. Клонирование объектов и функции-конструкторы

## Клонирование объектов

Клонирование объектов осуществляется либо **вручную**, последовательным перебором составляющих и их генерацией в клоне (в т.ч. и глубокое копирование, см. ниже, **через рекурсию**), либо с помощью импортируемых функций с готовым алгоритмом (гугл в помощь).

```javascript
function cloneDeepObj(ret, obj) { // глубокий алгоритм
    for (let key in obj) {
        if ((typeof obj[key]) == "object") {
            ret[key] = cloneDeepObj({}, obj[key]);
        } else {
            ret[key] = obj[key];
        }
    }
    return ret;
}
```

```javascript
let lib = {...book}; // поверхностное копирование, копирует только ссылки у объектов нижних уровней.
let lib = cloneDeepObj({}, book); // сначала передаем пустой объект, в который будут записаны скопированные данные
// после чего переменная будет ссылаться на этот объект, затем передаем объект, который хотим скопировать.
```

## Функции-конструкторы для объектов (или классы)

- Функции-конструкторы, как и классы, должны начинаться с прописной буквы.
- Роль `self` выполняет `this`.

```javascript
function Book(title, author) {
    // this = {};  (неявно)
    this.title = title;
    this.author = author;
    this.price = 10;
    // return this;  (неявно)
}
```

- Инициализация объектов выполняется посредством `new`.

```javascript
let book2 = new Book("Онегин", "Пушкин");
```

- Допускается прописывание логики класса непосредственно при создании экземпляра (для анонимной функции).

```javascript
let car = new function() {
    this.model = "reno";
    this.go = function() {
        console.log("машина едет");
    }
}
```

- Для инициализации объектов без использования префикса `new` можно прописать в функции автогенерацию оного.

```javascript
function Book(title, author) {
    if (new.target == undefined) // если вызвали без new
        return new Book(title, author); // добавим new автоматически
    this.title = title;
    this.author = author;
    this.price = 10;
}
```

- При переопределении `return` в функции-конструкторе, если он возвращает объект, то приоритет остается **за ним**, а если возвращает примитив, то **это никак не отразится на программе**.

```javascript
function User() {
    this.name = "user1";
    return {name: "user2"}; // сработает
}

function User() {
    this.name = "user1";
    return 5; // проигнорирует
}
```
