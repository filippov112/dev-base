#lang #lang-js 

---
### Всплытие события

|   |   |
|---|---|
| <div id="first" onclick="showTag(event)">div<br><br><p id="second" onclick="showTag(event)">p<br><br><span id="third" onclick="showTag(event)">span</span><br><br></p><br><br></div> | ![](heap/_files/js/Pasted%20image%2020241002012103.png) |

События в браузерной среде, срабатывая на любом дочернем элементе, переходят к его родителю, и там тоже возникает такое же событие. И так далее до самого корневого объекта.

```javascript
function showTag(event) {
    console.log(event.currentTarget.tagName); // текущий обработчик
}
```

```javascript
function showTag(event) {
    console.log(event.currentTarget.tagName + " от " + event.target.tagName); // корневой обработчик
}
```

Так всплывают почти все события в JavaScript. Но есть исключения. Например, событие **focus** не всплывает.

### Остановка всплытия и прерывание обработчика

- `event.stopPropagation();` - прерывает только текущий обработчик.
- `event.stopImmediatePropagation();` - прерывает все обработчики события на элементе.

> **Важно:** Не вызывайте без строгой необходимости методы остановки процесса всплытия события, так как ряд элементов имеют **автоматические обработчики стандартных событий**.

|   |   |
|---|---|
| На самом деле, события, **прежде чем всплыть, сначала погружаются**. Вот картинка, взятая из спецификации языка JavaScript, которая представляет жизненный цикл события. | ![](heap/_files/js/Pasted%20image%2020241002012120.png) |

### Отслеживание событий на стадии погружения

**Добавление:** Указывается 3-м параметром `elem.addEventListener(..., {capture: true});`

```javascript
first.addEventListener("click", showTag, true);
```

**Удаление:**

```javascript
first.removeEventListener("click", showTag, true);
```

Таким образом можно на **одно** событие **одного** элемента привязать **один** и тот же обработчик **2 раза**: один **на всплытие** – стандартным способом, и один **на погружение** (как здесь).
