## Подготовка исходных данных

Задаем число итераций работы алгоритма, и веса a, b для соотношения степени качества сохраняемого контента и стилизации изображения.

```python
num_iterations=100      # число итераций работы алгоритма
content_weight=1e3       # веса a, b 
style_weight=1e-2
```

Получим тензоры для исходников при помощи прописанной ранее функции. И сразу граммируем тензоры стилей картины.

```python
style_features, content_features = get_feature_representations(model)
gram_style_features = [gram_matrix(style_feature) for style_feature in style_features]
```

Инициализируем стилизованные котики как копию обычных:

```python
init_image = np.copy(x_img)
init_image = tf.Variable(init_image, dtype=tf.float32)   # подгоняем переменную под формат TF
```

Настраиваем оптимизатор и переменные хранения:

```python
opt = tf.compat.v1.train.AdamOptimizer(learning_rate=2, beta1=0.99, epsilon=1e-1)
iter_count = 1                        # номер текущей итерации

best_loss, best_img = float('inf'), None      # лучшие потери, лучшее изображение
loss_weights = (style_weight, content_weight)  # веса a, b

cfg = {                             # словарь конфигурации для функции качества
      'model': model,
      'loss_weights': loss_weights,
      'init_image': init_image,
      'gram_style_features': gram_style_features,
      'content_features': content_features
}

norm_means = np.array([103.939, 116.779, 123.68])    # константы преобразования исходников
min_vals = -norm_means                    
max_vals = 255 - norm_means
imgs = []                          # хранилище изображений после каждой итерации
```

Возвращаем конечные показатели (суммарный и по отдельности).

```plaintext
re, content_score
```


