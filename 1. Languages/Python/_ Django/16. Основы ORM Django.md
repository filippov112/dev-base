#lang #lang-python #django

---
**ORM** - это оболочка, которая используется Django для отправки SQL-запросов к БД, вне зависимости от типа последних. Смотри урок 5 с основами ORM. Продолжение темы.

Все подробности на сайте [djbook.ru](https://djbook.ru/rel3.0/).

В разделе «ORM и работа с базой данных» и подразделе «QuerySet». В частности, ссылка на «методы QuerySet»:
[Методы QuerySet](https://djbook.ru/rel3.0/ref/models/querysets.html)

---

1. Можно использовать срезы при выборке записей.

2. Можно использовать `.reverse()` в конце запроса для обратного порядка.

3. От записи (a) первичной таблицы можно обращаться к списку (тип object) всех связанных записей вторичной таблицы так: 
   ```python
   a.имя_вторичной_таблицы_set.all()
   ```
   Можно указать свое имя через параметр внешнего ключа вторичной таблицы `related_name='get_posts'`.

4. Операторы для создания условий для фильтров называются лукапы. Их список можно найти на сайте. Вот два знакомых:
   - `<имя атрибута>__gte` – сравнение больше или равно (>=);
   - `<имя атрибута>__lte` – сравнение меньше или равно (<=).
   
   Полный список можно посмотреть по ссылке (в разделе Field lookups):
   [Field lookups](https://djbook.ru/rel3.0/ref/models/querysets.html)

5. Для оперирования логическими операторами типа и, или, не используется класс **Q**:
   - Оператор "и" используется по умолчанию в виде перечисления условий через запятую.
   - `Q(условие) | Q(условие2)` - или.
   - `~Q(условие2)` - не.
   - `Q(условие) & Q(условие2)` - и.

6. Можно отбирать только первую или только последнюю запись после выборки с помощью добавления `.first()` или `.last()`.

6.1. Можно отбирать самые ранние или поздние записи по полям типа даты:
   - `.earliest('time_update')`
   - `.latest('time_update')`

7. Через запись (а) можно получить следующую либо предыдущую запись (по времени) таблицы:
   ```python
   w.get_previous_by_time_update()  # предыдущая запись по полю time_update
   w.get_next_by_time_update()      # следующая запись по полю time_update
   ```
   В параметры к ним можно также ставить условия выборки.

8. Методы:
   - `.exists()` – проверка существования записи.
   - `.count()` – получение количества записей.

9. Агрегаторы применяются в качестве параметра к дополнению `.aggregate()`. Их требуется импортировать:
   ```python
   from django.db.models import *
   ```
   Так внутри `aggregate` можно выполнять арифметические операции с записями в виде:
   ```python
   res = "какие-то действия"
   ```
   Результат будет представлен словарем `'res':'результат вычислений'`:
   ```python
   Women.objects.aggregate(res=Sum('cat_id') - Count('cat_id'))
   ```

10. Если при запросе выборки нам не нужны все поля записей, то перед фильтром выборки можно указать требуемые поля для экономии времени:
    ```python
    .values('title', 'cat_id').all()
    ```

11. Для формирования группировки в запросе можно использовать связку:
    ```python
    .values('поле группировки').annotate(операция над группой, например count(id))
    ```
    При группировке необходимо убедиться, что в классе представления **Meta** модели таблицы не стоит сортировка по другим полям `ordering`.

12. При использовании `.annotate(переменная=Count('связанная таблица'))` получится список записей, у каждой из которых будет свойство `'переменная'`, к которому можно будет обратиться. Или можно будет применить выборку к полученному списку (в том числе по этому свойству).

13. Для взаимодействия с разными полями в условиях фильтров можно оборачивать дополнительные поля в объекты класса **F** (как с классом **Q**).

14. Для ручного SQL-запроса можно использовать следующий синтаксис:
    ```python
    Manager.raw('запрос')
    Category.objects.raw('запрос')
    ```
    Таблицы по умолчанию именуются по типу "имя_приложения_имя_таблицы" (например, `women_cathegory`).

    - При ручном запросе должно обязательно запрашиваться поле `id`.
    - Для инъекции переменной в запрос, где `slug` – наша переменная:
    ```sql
    raw("SELECT .... WHERE slug='%s'", [slug])
    ```
