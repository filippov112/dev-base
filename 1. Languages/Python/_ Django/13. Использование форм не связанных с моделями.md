 #lang #lang-python

# 13. Использование форм не связанных с моделями

В Django существует класс `Form`, на базе которого удобно создавать формы, не связанные с моделями. Для хранения всех форм приложения обычно создают отдельный файл `forms.py`.

---

## 1. Импортируем пакет форм и модели

```python
from django import forms
from .models import *
```

## 2. Объявим класс формы

`AddPostForm` описывает форму добавления статьи. Имена полей в отличие от форм-моделей создаются с произвольными именами, и занесение данных происходит вручную. Так при взаимодействии с одной таблицей мы указываем те же имена, что и имена полей, чтобы направить словарь запроса сразу в функцию добавления.

```python
class AddPostForm(forms.Form):
    title = forms.CharField(max_length=255, label="Заголовок")
    slug = forms.SlugField(max_length=255, label="URL")
    content = forms.CharField(widget=forms.Textarea(attrs={'cols': 60, 'rows': 10}), label="Контент")
    is_published = forms.BooleanField(label="Публикация")
    cat = forms.ModelChoiceField(queryset=Category.objects.all(), label="Категории")
```

Смотреть документацию: [Django Forms Documentation](https://djbook.ru/rel3.0/ref/forms/fields.html)

## 3. Создаем в представлении экземпляр формы и передаем его в шаблон

```python
def addpage(request):
    form = AddPostForm()
    return render(request, 'women/addpage.html', {..., 'form': form})
```

## 4. Настроим сохранение данных формы при возврате на страницу в случае ошибки

```python
def addpage(request):
    if request.method == 'POST':  # ставим проверку на входящий запрос
        form = AddPostForm(request.POST)  # создаём экземпляр на основе POST-запроса
    else:
        form = AddPostForm()
    return render(request, 'women/addpage.html', {..., 'form': form})
```

## 5. Добавляем отображение формы в шаблоне

```html
<form action="{% url 'add_page' %}" method="post">
    {% csrf_token %}  <!-- защита от парсинга -->
    {{ form.as_p }}    <!-- инициализация полей -->
    <button type="submit">Добавить</button>
</form>
```

---

## 6. Можно инициализировать поля вручную

```html
<label class="form-label" for="{{ form.title.id_for_label }}">{{ form.title.label }}: </label>{{ form.title }}
```

Также можно вывести сообщения об ошибках:

- Для конкретных полей: `{{ form.title.errors }}`
- Прочие ошибки: `{{ form.non_field_errors }}`

В классе формы можно добавлять виджеты в параметры полей для кастомной стилизации через отдельный класс:

```python
title = forms.CharField(max_length=255, label="Заголовок", widget=forms.TextInput(attrs={'class': 'form-input'}))
```

---

## 7. Оформим добавление отправленных формой данных в БД

```python
def addpage(request):
    if request.method == 'POST':  # ставим проверку на входящий запрос
        form = AddPostForm(request.POST)
        if form.is_valid():  # проверяем валидность
            try:
                Women.objects.create(**form.cleaned_data)  # form.cleaned_data возвращает словарь из данных формы
                return redirect('home')
            except:
                form.add_error(None, 'Ошибка добавления поста')
    else:
        form = AddPostForm()
    return render(request, 'women/addpage.html', {..., 'form': form})
```

---

В результате нам пришлось в классе `AddPostForm` дублировать поля, описанные в модели `Women`, и, кроме того, вручную выполнять сохранение данных в таблицу `women`.
