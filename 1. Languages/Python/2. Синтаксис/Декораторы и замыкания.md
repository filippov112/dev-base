#lang #lang-python

# Декораторы и замыкания

**Декоратор функции** — расширяет функционал основной функции.
**Замыкание** — паттерн, при котором внутренняя функция ссылается на объект внешней функции и может использовать любые её локальные переменные.

> **Примечание:** Пока на декоратор ссылается хотя бы одна функция, он продолжает висеть в памяти программы (замыкание).  
> То же самое произойдет, если есть переменная-указатель, которая ссылается на замыкание.

### Пример декоратора
```python
import time

def testTime(fn):  # Декоратор функции
    def wrapper(*args):  # Обёртка — расширяет функционал основной функции, вызываемой через fn
        st = time.time()
        fn(*args)  # Обычный вызов основной функции
        # res = fn(*args)  # Сохранение возвращаемых данных исходной функции
        dt = time.time() - st
        print(f"Время работы: {dt} сек")
        # return res  # Так оболочка будет возвращать обработанный результат работы исходной функции
    return wrapper  # Возвращаемое значение декоратора — функция (обёртка), внутри которой находится основная функция

@testTime  # Эта строчка позволяет вызывать исходную функцию сразу в декораторе (замыкание)
def getNOD(a, b):  # Основная функция которую нужно обернуть в декоратор
    while a != b:
        if a > b:
            a -= b
        else:
            b -= a
    return a

test1 = testTime(getNOD)  # test1 становится функцией // если есть @testTime, то достаточно просто вызвать getNOD
test1(10000, 2)  # Через обращение к test1 мы обращаемся к исходной функции в обёртке
testTime(getNOD)(10000, 2)

```
