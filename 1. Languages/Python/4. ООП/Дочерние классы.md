#lang #lang-python

---
### Класс `Person`
```python
class Person:
    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c
    
    def drow(self):
        raise NotImplementedError("Абстрактные методы требуют своего переопределения во всех дочерних классах.")
```

### Класс `Student`
```python
class Student(Person):
    def __init__(self, name, surname, stipendia):
        super().__init__(name, surname, stipendia)
        print("Student created")
        self.stipendia = stipendia  # Дочерний атрибут
    
    def drow(self):
        print("abc")
```

### Примечание
- При наличии двух одинаковых методов в классе родителе и классе наследнике, выполнится метод класса наследника.
- `super()` используется для обращения к родительскому классу, будь то к методу или конструктору.
- Пример множественного наследования:
```python
class Student(Person1, Person2):
    def __init__(self, a, b):
        super().__init__(a, b)  # Вызываем конструктор первого родителя Person1
```

### Классы `Person1` и `Person2`
```python
class Person1:
    def __init__(self, a, *args):
        self.a = a
        super().__init__(*args)  # Первый родитель забирает себе нужное количество аргументов, оставшиеся передаются второму родителю.

class Person2:
    def __init__(self, b, *args):
        self.b = b
        super().__init__(*args)  # Второй родитель забирает оставшиеся необходимые аргументы.
```
- Последний `super()` не обязателен, если `Person2` всегда стоит последним в списке родителей. Он не повлияет на выполнение программы, так как интерпретатор достигнет базового класса `object`, если все аргументы были использованы.
