#lang #lang-python 

---
### 1. Использование встроенных функций и библиотек
Встроенные функции Python и библиотеки, такие как `numpy`, часто более оптимизированы, чем эквивалентные самописные функции.
```python
# Медленный способ
result = []
for i in range(1000000):    
	result.append(i * 2)

# Быстрый способ
result = [i * 2 for i in range(1000000)]
```

### 2. Использование `numpy` для численных операций
Библиотека `numpy` значительно ускоряет операции с массивами чисел.
```python
import numpy as np

# Медленный способ
result = [i * 2 for i in range(1000000)]

# Быстрый способ
arr = np.arange(1000000)
result = arr * 2
```

### 3. Использование `multiprocessing` для параллелизма
Для задач, которые могут быть распараллелены, `multiprocessing` может значительно ускорить выполнение.
```python
from multiprocessing import Pool
def square(x):    
	return x * x

# Медленный способ
result = [square(i) for i in range(1000000)]

# Быстрый способ
with Pool(4) as p:    
	result = p.map(square, range(1000000))
```

### 4. Компиляция с использованием Cypthob
`Cython` позволяет компилировать Python-код в C для ускорения выполнения.
```python
# example.pyx
def square(int x):    
	return x * x

# В терминале
# cythonize -i example.pyx
```

### 5. Избегайте глобальных переменных
#### Оборачивайте код в функции
Глобальные переменные могут замедлить выполнение из-за их поиска в глобальной области видимости.
```python
# Медленный способ
global_var = 0

def increment():    
	global global_var    
	global_var += 1

# Быстрый способ
def increment(local_var):    
	return local_var + 1
```

### 6. Используйте Генераторы списков с вложенными циклами
Генераторы списков могут использовать вложенные циклы для создания новых списков. И если у нас есть 2 списка, и вы хотите получить список всех возможных пар элементов из этих списков, вы можете использовать такой синтаксис
```python
list1 = [1, 2, 3]
list2 = ['a', 'b', 'c']
pairs = [(x, y) for x in list1 for y in list2]
print(pairs)

# Output: [(1, 'a'), (1, 'b'), (1, 'c'), (2, 'a'), (2, 'b'), (2, 'c'), (3, 'a'), (3, 'b'), (3, 'c')]
```

### 7. Использование функции lry_cache для мемоизации
`functools.lru_cache` может кэшировать результаты вызова функции для ускорения повторных вычислений.
```python
from functools import lru_cache

@lru_cache(maxsize=None)
def fibonacci(n):    
	if n < 2:        
		return n    
	return fibonacci(n-1) + fibonacci(n-2)
```

### 8. Сортировка с использованием ключевых функций
Функция `sorted` с аргументом `key` может быть быстрее для сложных критериев сортировки.
```python
data = ["apple", "orange", "banana", "grape"]

# Медленный способ
data.sort(lambda x: len(x))

# Быстрый способ
data.sort(key=len)
```

### 9. Использование Itertools для работы с итераторами
Модуль `itertools` предоставляет эффективные функции для работы с итераторами.
```python
import itertools

# Медленный способ
result = [x + y for x in range(1000) for y in range(1000)]

# Быстрый способ
result = itertools.product(range(1000), repeat=2)
```

### 10. Профилирование и оптимизация кода
Использование профилировщика для поиска узких мест в коде помогает определить, что именно нужно оптимизировать.
```python
import cProfile
import pstats

def main():    
	# Ваш код здесь    
	pass

cProfile.run('main()', 'restats')
p = pstats.Stats('restats')
p.sort_stats('cumulative').print_stats(10)
```

### 11. Не обращайтесь к атрибутам
Ещё один механизм, способный замедлить программу — это оператор точка (`.`), который используется для доступа к атрибутам объектов. Этот оператор вызывает выполнение процедуры поиска по словарю с использованием `__getattribute__`, что создаёт дополнительную нагрузку на систему. Как ограничить влияние этой особенности Python на производительность?  

```python
#  Медленно:
import re
def slow_func():    
	for i in range(10000):        
		re.findall(regex, line)  # Медленно!

#  Быстро:
from re import findall
def fast_func():    
	for i in range(10000):        
	findall(regex, line)  # Быстрее!
```

### 12. Остерегайтесь строк
Операции на строках могут сильно замедлить программу в том случае, если выполняются в циклах. В частности, речь идёт о форматировании строк с использованием `%s` и `.format()`. Можно ли их чем-то заменить? Если взглянуть на недавний [твит](https://twitter.com/raymondh/status/1205969258800275456) Раймонда Хеттингера, то можно понять, что единственный механизм, который надо использовать в подобных ситуациях — это f-строки. Это — самый читабельный, лаконичный и самый быстрый метод форматирования строк. Вот, в соответствии с тем твитом, список методов, которые можно использовать для работы со строками — от самого быстрого к самому медленному:  
  
```python
f'{s} {t}'  # Быстро!

s + '  ' + t

' '.join((s, t))

'%s %s' % (s, t)

'{} {}'.format(s, t)

Template('$s $t').substitute(s=s, t=t)  # Медленно!
```

### 13. Использовать comprehension

Код выше можно написать короче, используя генератор списка.

```
admins = [user for user in get_users() if user.is_admin]
```

Более того, такое решение будет работать немного быстрее, так как comprehension-ы - оптимизированы для создания объектов. Не забываем также, что подобным образом можно создавать словари и множества.

Эта же конструкция признается сообществом как более _pythonic way_ для фильтрации

```
# Вместоactive_users = list(filter(lambda user: user.is_active, get_users()))# Лучшеactive_users = [user for user in get_users() if user.is_active]
```

### 14. Вложенные циклы for в comprehension

Предположим, у нас есть задача сформировать список комбинаций элементов двух коллекций.

```
numbers = ["1", "2", "3"]letters = ["A", "B", "C"]# Хотим ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']
```

Даже знакомые с генераторами списков могу не знать о небольшом сахаре и написать вложенный цикл.

```
spots = []for letter in letters:    for number in numbers:        spots.append(letter + number)# Хотя и можно такspots = [letter + number for letter in letters for number in numbers]
```

Удобная штука, эти компрехеншены) Но не серебряная пуля. Обещаем не использовать их при наличии сложной логики во время итераций (это снизит читаемость) и идем дальше.

### 15. Логические операторы вместо тернарного

Логические операторы часто можно использовать для задания значения переменной. Многие знакомы с тернарным оператором и избегают лишних if-else, однако и от первого можно уйти в некоторых случаях.

```
# Есть переменная, которая может быть не заполненаuser: User | None# Задаем админа тернарникомadmin = user if user else get_user()# Но можно и корочеadmin = user or get_user()# Цепочку можно продолжать. Вернется первое приводимое к True значениеadmin = get_admin() or user or get_user()
```

### 16. Использование оптимизации проверки условий

Если python явно узнаёт значение условия, он не производит дальнейших проверок.

Пример. Мы хотим убедиться, что последний из аппрувнувших людей обладает админскими правами. Но список аппрувнувших может быть и пустым.

Чтобы не получить `"IndexError: list index out of range"`,  
часто вижу, что начинающие разработчики сначала проверяют список на пустоту

```
approvers: list[User] = []if approvers:    if approvers[-1].is_admin:        return Truereturn False
```

Однако мы можем и совместить условия, упростив наш код:

```
approvers = []if approvers and approvers[-1].is_admin:    return Truereturn False
```

Здесь, если `approvers` пустой, то общее условие уже никак не может быть `True`. Поэтому дальнейшие проверки не производятся, и за границы списка мы не выходим.

Работает также и в обратную сторону для `or`

```
approvers = []# Если первое условие уже `True`, то часть с `or` не имеет значенияapproved_by_admin = Trueif approved_by_admin == True or approvers[-1].is_admin:    return Truereturn False
```

### 17. Использование магии bool

Как ни странно, в python `True` и `1` равны. Как и `False` c `0`

```
>>> True == 1True>>> False == 0True
```

Помимо багов, это может и здорово сыграть нам на руку. Снова пример.

Представим, что мы решили бросить программирование и ударились ростовщичество. Математическое прошлое подсказывает, что нужна какая-то система принятия решения о выдаче кредита, и мы выбираем самую передовую из известных нам.  
А именно: мы собираемся анализировать три показателя у заемщика.

- наличие дома
    
- наличие машины
    
- наличие работы
    

Если какие-либо два из них положительны, то клиент, скорее всего, кредит отдаст, поэтому мы дадим ему деньги. Приступаем!

```
has_a_house: boolhas_as_car: boolhas_a_job: boolif has_a_house and has_a_car:    return Trueif has_a_house and has_a_job:    return Trueif has_a_car and has_a_job:    return True
```

Вроде работает, но смущает нездоровое количество if-ов... А если факторов будет не три, а 100, и для положительного ответа нужно будет набрать минимум 60 очков? Переписываем.

```
factors = [has_a_house, has_as_car, has_a_job]total = 0for factor in factors:    if factor:        total += 1return total >= 2
```

Уже лучше, но если мы воспользуемся тем, что булево `True` равняется единице, то получим изящный однострочник

```
return sum(factors) >= 2# здесь sum сложит все единицы. По сути, посчитает количество True.
```

### 18. Использование any и all

Если бы в предыдущем примере мы захотели проверить условия на

- хотя бы одно
    
- все
    

Мы бы просто могли воспользоваться конструкциями `any` и `all` соответственно

```
any([True, False, False])# Trueany([False, False, False])# Falseall([True, True, True])# Trueall([True, True, False])# False
```

### 19. Сниппет для проверки пути в JSON-е

Когда мы работаем с JSON-ами внешних сервисов, элементы в них могут быть опциональны. Причем бывает так, что дерево пути может оборваться в любой момент.

В данном примере хотим проверить наличие прав у пользователя на создание других пользователей. Для таких случаев сталкивался с таким вот кодом:

```
user_dict = {    "user": {        "username": "PetyaNagibator228",        "permissions": {            "create_troubles": True,            "create_users": True        }    }}if user := user_dict.get("user"):    if permissions := user.get("permissions"):        if permissions.get("create_users"):            return Truereturn False
```

Громоздко. Еще моржовые операторы эти. Было бы здорово обращаться к элементу прям по пути

`path = "user.permissions.create_users"`

Такое можно реализовать при помощи однострочника

```
path = "user.permissions.create_users"reduce(dict.get, path.split('.'), user_dict)# True
```

Однако у него есть несколько недостатков.

- reduce у новичков вызывает недопонимания
    
- решение не гибкое, если мы хотим иметь больше возможностей по обработке элементов
    

Возможно, более адаптируемым под Ваши нужды окажется прямолинейное решение:

```
def find(path: str, dict_: dict):    keys = path.split(".")    data = dict_    for key in keys:        try:            data = data.get(key)        except AttributeError:            return None    return datafind("user.permissions.create_users", user_dict)# Truefind("user.permissions.no_key.create_users", user_dict)# None
```

### 20. Генераторы для экономии памяти и кода

Уверен, что в любом уважающем себя курсе рассказывают про генераторы и про то, зачем они нужны. Однако это не мешает многим начинающим ребятам обходить пагинацию следующим образом:

```
j = {    "pagination": {        "page": 0,  # текущая страница        "limit": 3  # кол-во элементов на странице    },    "user_ids": [1, 2, 3]}users = []limit = 3page = 0while True:    rsp = client.get_all_users(page=page, limit=limit)    if not rsp.get("user_ids"):        break    users.extend(rsp["user_ids"])    page += 1return users
```

Здесь создается список пользователей и наполняется до тех пор, пока внешний сервис отдает данные. Как только пагинация будет исчерпана, возвращается созданный список.

Используя подобную конструкцию, мы должны понимать, что весь итоговый список пользователей будет храниться в памяти. Что как минимум не очень эффективно. К тому же, существуют расходы на постоянное расширение данного списка на каждой итерации.

Здесь как нельзя лучше находят свое применение те самые генераторы.

```
limit = 3page = 0while True:    rsp = client.get_all_users(page=page, limit=limit)    if not rsp.get("user_ids"):        break    yield rsp["user_ids"]    page += 1
```

Так мы возвращаем пользователей пачками, сэкономив ресурсы машины.

### 21. Ограничение пагинации

Существует такая вещь, как ограничение глубины рекурсии. Она нужна для избегания бесконечной вложенности. К сожалению, работая с внешними API, я не один раз сталкивался с багами, приводящими к бесконечным обходам пагинации. В примере выше цикл так и будет крутиться, если по какой-то причине не выполнится условие `break`. Например, если API будет всегда возвращать данные, не зависимо от передаваемого `page`.

Для таких случаев не лишним было бы иметь некий предохранитель, которым часто пренебрегают.

```
max_pages = 5for i in range(max_pages + 1):      rsp = client.get_all_users(page=page, limit=limit)    if not rsp.get("user_ids"):        break    if i >= max_pages:        raise RuntimeError("Too many pagination elements")    yield rsp["user_ids"]
```