#Python #NumPy

# 6. Индексация, срезы, итерирование массивов

---

## Срезы и выборка

```python
a = b[2:]  # при создании ссылки на срез формируется только представление, а не новый массив.
a[:, 1, :, :]  # срезы можно использовать и с многомерными массивами, например для взятия векторов.
a[..., 1, 1]  # эквивалент a[:, :, 1, 1]

for val in x.flat:  # перебирать элементы многомерного массива можно с помощью свойства flat.
    print(val, end=' ')
```

---

## Списочная индексация

```python
b = a[[0]]  # создание ссылки на вложенный массив создаёт КОПИЮ МАССИВА. Аналогично array(a) или copy(a)

bIndx = [True, True, False, False, False, True, False, False]  # при формировании bool-выборки число индексов и элементов массива должны совпадать
a[bIndx]
```

Мы можем сформировать массив индексов путем какой-либо булевой операции над массивом. В этом случае все элементы массива перебираются на соответствие условию, и на основе проверок формируется массив с результатами:

```python
i = a > 5  # array([False, False, False, False, False,  True,  True,  True])  # остаются элементы, которые >5
a[i]  # array([6, 7, 8])
a[a > 5]  # то же самое в одну строчку
```

---

## Многомерная списочная индексация

Если взять тот же одномерный массив:

```python
a = np.arange(1, 9)
```

но набор индексов определить как двумерный массив:

```python
i = np.array([[0, 1], [2, 3]])
```

то на выходе будет формироваться уже двумерный массив:

```python
a[i]  # array([[1, 2], [3, 4]])  # здесь обращаемся к первой оси (axis 0)
```

Всё так же работает и в случае с многомерными массивами. Индексы массива "i" заменяются на соответствующие им подтаблицы массива "а".

> **Важно:** Только в этом случае индексы `i` должны определяться именно массивом NumPy, а не списком Python.

### Пример:

```python
i0 = [0, 1]		
i1 = [1, 2]
a[i0, i1]  # через i0 обращаемся к первой оси (axis 0); а через i1 - ко второй (axis 1). Координаты соотносятся попарно. (0-1, 1-2)
```

Если число строк и столбцов (координат по разным осям) не совпадает, то вместо попарного соотношения берутся все возможные пересечения. Поскольку индексация не многомерная, мы можем использовать обычные списки.

---

## Арифметические операции с выборками массивов

```python
a = np.arange(7)  # array([0, 1, 2, 3, 4, 5, 6])
a[[0, 4, 6]] = [-1, -2, -3]  # array([-1,  1,  2,  3, -2,  5, -3])  # множественное присваивание
a[[0, 0, 0, 1]] = [1, 2, 3, 100]  # array([  3, 100,   2,   3,  -2,   5,  -3])  # при множественном обращении сохраняется только последняя операция
a[[0, 0, 0]] = a[[0, 0, 0]] + 3  # array([  6,...]  # т.е. предыдущие операции не учитываются.
```
