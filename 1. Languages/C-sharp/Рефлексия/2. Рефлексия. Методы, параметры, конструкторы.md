#lang #lang-c_sharp 

---
### Методы - `MethodInfo`

1. **Свойства**:
	- `IsAbstract`: возвращает `true`, если метод абстрактный    
	- `IsFamily`: возвращает `true`, если метод имеет модификатор доступа `protected`    
	- `IsFamilyAndAssembly`: возвращает `true`, если метод имеет модификатор доступа `private protected`  
	- `IsFamilyOrAssembly`: возвращает `true`, если метод имеет модификатор доступа `protected internal`
	- `IsAssembly`: возвращает `true`, если метод имеет модификатор доступа `internal`
	- `IsPrivate`: возвращает `true`, если метод имеет модификатор доступа `private`
	- `IsPublic`: возвращает `true`, если метод имеет модификатор доступа `public`
	- `IsConstructor`: возвращает `true`, если метод предоставляет конструктор
	- `IsStatic`: возвращает `true`, если метод статический
	- `IsVirtual`: возвращает `true`, если метод виртуальный  
	- `ReturnType`: возвращает тип возвращаемого значения
2. **Методы**:
	- `GetMethodBody()`: возвращает тело метода как объект `MethodBody`.
	- `GetParameters()`: возвращает параметры метода.
3. **Вызов методов**: `public object? Invoke (object? obj, object?[]? parameters);`: позволяет вызвать метод. 
	- 1p: `MethodInfo`, для которого вызывается метод. 
	- 2p: Массив параметров метода. 
	- Возвращает - `object?`.
4. **Вызов обобщенных методов**: Используется `MakeGenericMethod`, чтобы типизировать метод определенным типом.


### Параметры - `ParameterInfo`
С помощью `GetParameters()` можно получить параметры метода.
Если параметр имеет модификатор `ref, in, out`, то в конце названия типа добавляется амперсанд - `String&`.
1. **Свойства:**
	- `Attributes`: возвращает атрибуты параметра
	- `DefaultValue`: возвращает значение параметра по умолчанию
	- `HasDefaultValue`: возвращает `true`, если параметр имеет значение по умолчанию
	- `IsIn`: возвращает `true`, если параметр имеет модификатор `in`
	- `IsOptional`: возвращает `true`, если параметр является необязательным
	- `IsOut`: возвращает `true`, если параметр является выходным, то есть имеет модификатор `out`
	- `Name`: возвращает имя параметра
	- `ParameterType`: возвращает тип параметра


### Конструкторы - `ConstructorInfo`
Метод `GetConstructors()` возвращает массив объектов `ConstructorInfo`.
Свойства и методы большинство те же что и у `MethodInfo`.

---

### Примеры кода

**Пример использования `GetMethods` и фильтрации методов**
```csharp
using System.Reflection;

Type myType = typeof(Printer);

Console.WriteLine("Методы:");
foreach (MethodInfo method in myType.GetMethods())
{
    string modificator = "";

    if (method.IsStatic) modificator += "static ";
    if (method.IsVirtual) modificator += "virtual ";

    Console.WriteLine($"{modificator}{method.ReturnType.Name} {method.Name} ()");
}
```

```
String get_DefaultMessage ()
Void set_DefaultMessage ()
Void PrintMessage ()
String CreateMessage ()
```

**Использование `BindingFlags` для получения методов без унаследованных**
```csharp
using System.Reflection;

Type myType = typeof(Printer);

Console.WriteLine("Методы:");
foreach (MethodInfo method in myType.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public))
{
    Console.WriteLine($"{method.ReturnType.Name} {method.Name} ()");
}
```

**Исследование параметров метода:**
```csharp
using System.Reflection;

foreach (MethodInfo method in typeof(Printer).GetMethods())
{
    Console.Write($"{method.ReturnType.Name} {method.Name} (");
    ParameterInfo[] parameters = method.GetParameters();
    for (int i = 0; i < parameters.Length; i++)
    {
        var param = parameters[i];
        string modificator = param.IsIn ? "in" : param.IsOut ? "out" : "";
        Console.Write($"{param.ParameterType.Name} {modificator} {param.Name}");
        if (param.HasDefaultValue) Console.Write($"={param.DefaultValue}");
        if (i < parameters.Length - 1) Console.Write(", ");
    }
    Console.WriteLine(")");
}
```

**Пример вызова метода через `Invoke()`**
```csharp
var myPrinter = new Printer("Hello");
var print = typeof(Printer).GetMethod("Print");
print?.Invoke(myPrinter, parameters: null); // Hello
```

**Пример с обобщенным методом**
```csharp
var myPrinter = new Printer();
var printValue = typeof(Printer).GetMethod("PrintValue");
var printStringValue = printValue?.MakeGenericMethod(typeof(string));
printStringValue?.Invoke(myPrinter, new object[] {"Hello world"});
```

**Получение конструкторов**
```csharp
Type myType = typeof(Person);

Console.WriteLine("Конструкторы:");
foreach (ConstructorInfo ctor in myType.GetConstructors(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public))
{
    string modificator = ctor.IsPublic ? "public" : ctor.IsPrivate ? "private" : "";
    Console.Write($"{modificator} {myType.Name}(");
    ParameterInfo[] parameters = ctor.GetParameters();
    for (int i = 0; i < parameters.Length; i++)
    {
        var param = parameters[i];
        Console.Write($"{param.ParameterType.Name} {param.Name}");
        if (i < parameters.Length - 1) Console.Write(", ");
    }
    Console.WriteLine(")");
}
```

### Inner links:
[_ Рефлексия. Типы (System.Type)](1.%20Languages/C-sharp/Рефлексия/_%20Рефлексия.%20Типы%20(System.Type).md)

### Outer links:
https://metanit.com/sharp/tutorial/14.5.php