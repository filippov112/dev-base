#lang #lang-c_sharp 

---
#### 1. Реализуем интерфейс `IRouteConstraint`.

```csharp
public interface IRouteConstraint
{
    bool Match(HttpContext? httpContext,
            IRouter? route,
            string routeKey,
            RouteValueDictionary values,
            RouteDirection routeDirection);
}
```

- `httpContext`: инкапсулирует информацию о HTTP-запросе  
- `route`: маршрут, в рамках которого применяется ограничение 
- `routeKey`: название параметра маршрута, к которому применяется ограничение
- `values`: набор параметров маршрута в виде словаря
- `routeDirection`: объект перечисления, которое указывает, применяется ограничение при обработке запроса, либо при генерации ссылки
- В качестве результата: `true` - если зпрос удовлетворяет данному ограничению маршрута, и `false` - если не удовлетворяет.


#### 2. Регистрируем реализацию как inline-ограничение для использования в шаблонах.

```csharp
builder.Services.Configure<RouteOptions>(options =>
			    options.ConstraintMap.Add("secretcode", typeof(SecretCodeConstraint)));  // SecretCodeConstraint - класс реализации интерфейса ограничения

// или так

builder.Services.AddRouting(options =>
                options.ConstraintMap.Add("secretcode", typeof(SecretCodeConstraint)));
```

#### 3. Используем.

```csharp
app.Map(
    "/users/{name}/{token:secretcode(123466)}/",
    (string name, int token) => $"Name: {name} \nToken: {token}"
);
```

---

#### **Пример реализации:**

```csharp
public class SecretCodeConstraint : IRouteConstraint
{
    string secretCode;    // допустимый код
    public SecretCodeConstraint(string secretCode)
    {
        this.secretCode = secretCode;
    }
 
    public bool Match(HttpContext? httpContext, IRouter? route, string routeKey, RouteValueDictionary values, RouteDirection routeDirection)
    {
        return values[routeKey]?.ToString() == secretCode;
    }
}
```

### Outer links:
https://metanit.com/sharp/aspnet6/3.4.php