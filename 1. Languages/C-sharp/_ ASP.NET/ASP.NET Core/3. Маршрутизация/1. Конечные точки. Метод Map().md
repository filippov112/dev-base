#lang #lang-c_sharp #aspnet

---
**Конечная точка (endpoint)** - объединяет шаблон маршрута, которому должен соответствовать запрос, и обработчик запроса по этому маршруту.
**Интерфейс `Microsoft.AspNetCore.Routing.IEndpointRouteBuilder`** - служит для добавления конечных точек, (реализован через `WebApplication`).

> Для использования системы маршрутизации в конвейер ==автоматически== добавляются ==компилятором== два встроенных компонента:
> - `Microsoft.AspNetCore.Routing.EndpointMiddleware` добавляет в конвейер обработки запроса конечные точки. Добавляется с помощью метода `UseEndpoints()`
> - `Microsoft.AspNetCore.Routing.EndpointRoutingMiddleware` добавляет в конвейер обработки запроса функциональность сопоставления запросов и маршрутов, выбирает конечную точку, которая соответствует запросу и которая затем обрабатывает запрос. Добавляется с помощью метода `UseRouting()`

---

### Map()

Не путать с [Метод Map](1.%20Languages/C-sharp/_%20ASP.NET/ASP.NET%20Core/1.%20Основы/13.%20Метод%20Map.md) - методом расширения для `IApplicationBuilder`. Последний отвечает за ветвление конвейера обработки запросов.

**Метод `Map()` интерфейса `IEndpointRouteBuilder`** - добавляет конечные точки для обработки GET-запросов.

Т.е. `IApplicationBuilder.Map()` - если нужна отдельная ветка компонентов обработки,
а `IEndpointRouteBuilder.Map()` - если требуется только 1 компонент-обработчик запроса.

```csharp
public static RouteHandlerBuilder Map (this IEndpointRouteBuilder endpoints, RoutePattern pattern, Delegate handler);
public static RouteHandlerBuilder Map (this IEndpointRouteBuilder endpoints, string pattern, Delegate handler);
public static IEndpointConventionBuilder Map (this IEndpointRouteBuilder endpoints, string pattern, RequestDelegate handler);
```
- `pattern` - шаблон маршрута, которому должен соответствовать запрос - `RoutePattern` или `string`.
- `handler` - действие, которое будет обрабатывать запрос - делегат типа `RequestDelegate`, либо делегат `Delegate`.
- Перегрузка с `RequestDelegate handler` - используется если нужен доступ к `HttpContext`.

**Пример:**
```csharp
var builder = WebApplication.CreateBuilder();
var app = builder.Build();

// Никаких ограничений на возвращаемый тип или его отсутствие
app.Map("/", () => "Index Page");
app.Map("/user1", () => new Person("Tom", 37));
app.Map("/user2", () => Console.WriteLine("Request Path: /user"));
// RequestDelegate
app.Map("/about", async (context) =>
{
    await context.Response.WriteAsync("About Page");
});

// Пример если нужна информация по имеющимся конечным точкам
app.MapGet("/routes", (IEnumerable<EndpointDataSource> endpointSources) =>
{
    var sb = new StringBuilder();
    var endpoints = endpointSources.SelectMany(es => es.Endpoints);
    foreach (var endpoint in endpoints)
    {
        sb.AppendLine(endpoint.DisplayName);
 
        // получим конечную точку как RouteEndpoint
        if (endpoint is RouteEndpoint routeEndpoint)
        { 
            sb.AppendLine(routeEndpoint.RoutePattern.RawText);
        }
 
        // получение метаданных
        // данные маршрутизации
        // var routeNameMetadata = endpoint.Metadata.OfType<Microsoft.AspNetCore.Routing.RouteNameMetadata>().FirstOrDefault();
        // var routeName = routeNameMetadata?.RouteName;
        // данные http - поддерживаемые типы запросов
        //var httpMethodsMetadata = endpoint.Metadata.OfType<HttpMethodMetadata>().FirstOrDefault();
        //var httpMethods = httpMethodsMetadata?.HttpMethods; // [GET, POST, ...]
    }
    return sb.ToString();
});
 
app.Run();
 
record class Person(string Name, int Age);
```


### Outer links:
https://metanit.com/sharp/aspnet6/3.1.php