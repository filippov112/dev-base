#Csharp 

# LINQ, Объединение, пересечение, разность коллекций в C#

#### Разность последовательностей - `Except()`

```csharp
string[] soft = { "Microsoft", "Google", "Apple"};
string[] hard = { "Apple", "IBM", "Samsung"};
 
// разность последовательностей
var result = soft.Except(hard);
 
foreach (string s in result)
    Console.WriteLine(s);
```

```
Microsoft
Google
```

#### Пересечение последовательностей - `Intersect()`

```csharp
string[] soft = { "Microsoft", "Google", "Apple"};
string[] hard = { "Apple", "IBM", "Samsung"};
 
// пересечение последовательностей
var result = soft.Intersect(hard);
 
foreach (string s in result)
    Console.WriteLine(s);
```

```
Apple
```

#### Удаление дубликатов - `Distinct()`

```csharp
string[] soft = { "Microsoft", "Google", "Apple", "Microsoft", "Google" };
 
// удаление дублей
var result = soft.Distinct();
 
foreach (string s in result)
    Console.WriteLine(s);
```

```
Microsoft
Google
Apple
```

#### Объединение последовательностей - `Union()`
- Повторяющиеся элементы добавляются в результат только один раз.
- Если же нам нужно простое объединение двух наборов, то мы можем использовать метод `Concat`.

```csharp
string[] soft = { "Microsoft", "Google", "Apple"};
string[] hard = { "Apple", "IBM", "Samsung"};
 
// объединение последовательностей
var result = soft.Union(hard);

// var result = soft.Concat(hard);
 
foreach (string s in result)
    Console.WriteLine(s);
```

```
Microsoft
Google
Apple
IBM
Samsung
```

#### Работа со сложными объектами
- Для сравнения объектов в последовательностях применяются реализации методов `GetHeshCode()` / `Equals()`. 
- Поэтому для сравнения **классов** и **структур** их нужно переопределить.
> При переопределении метода `Equals()` в C# необходимо также переопределить метод `GetHashCode()` из-за свойств и требований, предъявляемых к хеш-коду, чтобы объекты могли корректно работать в коллекциях, зависящих от хеш-кодов, таких как `Dictionary` или `HashSet`. [2]
> А именно:
> 	- Хеш-коллекции базируются на данной спецификации идентичной работы методов.
> 	- При поиске сначала вычисляется участок памяти по GetHashCode, потом проверяется найденный в участке файл уже методом Equals.
> 	- В результате сложность операций возрастет с O(1) до O(n).

```csharp
Person[] students = { new Person("Tom"), new Person("Bob"), new Person("Sam") };
Person[] employees = { new Person("Tom"), new Person("Bob"), new Person("Mike") };
 
// объединение последовательностей
var people = students.Union(employees);
 
foreach (Person person in people)
    Console.WriteLine(person.Name);
 
 
class Person
{
    public string Name { get;}
    public Person(string name) => Name = name;
 
    public override bool Equals(object? obj)
    {
        if (obj is Person person) return Name == person.Name;
        return false;
    }
    public override int GetHashCode() => Name.GetHashCode();
}
```

```
Tom
Bob
Sam
Mike
```

### Inner links:
[_ LINQ](1.%20Languages/C-sharp/Базы%20данных/LINQ/_%20LINQ.md)

### Outer links:
1. https://metanit.com/sharp/tutorial/15.4.php
2. https://learn.microsoft.com/ru-ru/dotnet/api/system.object.gethashcode?view=net-8.0