#lang #lang-c_sharp 

---
**<font color="#ffff00">Мониторы (`Monitor`)</font>** — это механизм синхронизации в C#, позволяющий управлять доступом к разделяемым ресурсам. Они обеспечивают эксклюзивный доступ одного потока к критической секции кода, блокируя объект и предотвращая одновременное выполнение другими потоками.

<font color="#ffff00">Когда используются:</font>
- Когда нужно **гарантировать** атомарность операций.
- Для управления доступом к **разделяемым ресурсам**.
- В случаях, когда требуется **ожидание** освобождения блокировки.

<font color="#ffff00">Преимущества:</font>
- **Гибкость**: поддерживает `Wait()`, `Pulse()`, `PulseAll()` для управления ожиданием и оповещением потоков.
- **Автоматическое освобождение**: интегрирован с `lock`, который автоматически снимает блокировку при выходе из блока.
- **Более безопасен, чем `Mutex`**: работает внутри одного процесса и быстрее, так как не требует переключения контекста на уровень ядра.
- **Менее ресурсозатратен, чем `Semaphore`**: не ограничивает количество потоков, а просто блокирует доступ.

---
### Практика:

1. **`Monitor.Enter()` / `Monitor.Exit()`** - Захват и освобождение блокировки
	```csharp
	object lockObject = new object();
	
	void CriticalSection()
	{
	    Monitor.Enter(lockObject);
	    try
	    {
	        // Код, выполняемый одним потоком в момент времени
	        //Console.WriteLine("Работа в критической секции");
	    }
	    finally
	    {
	        Monitor.Exit(lockObject); // Гарантированное освобождение блокировки
	    }
	}
	```

2. **`Monitor.TryEnter()`** - Попытка захватить блокировку без ожидания или с тайм-аутом.
	```csharp
	if (Monitor.TryEnter(lockObject, TimeSpan.FromSeconds(1)))
	{
	    try
	    {
	        //Console.WriteLine("Блокировка получена");
	    }
	    finally
	    {
	        Monitor.Exit(lockObject);
	    }
	}
	else
	{
	    //Console.WriteLine("Не удалось получить блокировку");
	}
	```

3. **`Monitor.Wait()`** - Освобождает блокировку и приостанавливает выполнение потока до получения уведомления, после чего снова пытается занять блокировку.
	```csharp
	object lockObj = new object();
	
	void Waiter()
	{
	    lock (lockObj) // захватывает блокировку
	    {
	        Monitor.Wait(lockObj); // освобождает блокировку и приостанавливает выполнение потока.
	        // ...
	    }
	}
	```

4. **`Monitor.Pulse()`** - Уведомление одного потока в ожидании, что он может захватить блокировку и продолжить выполнение. 
	```csharp
	object lockObj = new object();
	
	void Signaler()
	{
	    lock (lockObj)
	    {
	        // Код, который изменяет состояние
	        Monitor.Pulse(lockObj); // Уведомление одного потока
	    }
	}
	```

5. **`Monitor.PulseAll()`** - Уведомляет все потоки, которые находятся в ожидании. 
	```csharp
	object lockObj = new object();
	
	void Signaler()
	{
	    lock (lockObj)
	    {
	        // Код, который изменяет состояние
	        Monitor.PulseAll(lockObj); // Уведомление всех потоков
	    }
	}
	```

### Outer links:
https://metanit.com/sharp/tutorial/11.5.php