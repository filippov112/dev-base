#Csharp 

# Наследование классов в C#

**Термины:**
- *Базовый класс* (родитель), 
- *Производный класс* (потомок) .
- *Upcasting, downcasting* - преобразования экземпляров классов между базовым классом и производным в одну и другую сторону. 
	- *Upcasting* (вверх, производный -> базовый) - выполняется неявно и без ограничений. 
	- *Downcasting* (вниз, базовый -> производный) - выполняется явно и возможен только после предварительного обратного upcasting-а.

**Ключевые слова:**
- `this` - точка обращения к экземпляру.
- `base` - точка обращения к функционалу класса родителя.
- `override` - модификатор переопределения метода базового класса в производном. <u>Поддерживает полиморфизм (имеет доступ к методу родителя)</u>
- [3. New](1.%20Languages/C-sharp/0.%20Введение/2.%20Классовые%20механизмы/3.%20New.md)
- `sealed` - модификатор класса, запрещающий наследование от данного класса.

**Наследуемые модификаторы доступа:**
- `private protected` (если базовый и производный класс находятся в одной сборке), 
- `public`, 
- `internal` (если базовый и производный класс находятся в одной сборке), 
- `protected`
- `protected internal`

#### Правила
1. Только 1 класс родитель.
2. Запрещено наследование от статических классов.
3. Конструкторы не передаются при наследовании.
4. Все конструкторы потомков должны явно или неявно (если не пишем `: base(...)`) вызывать конструкторы базового класса.
	1. Если в базовом классе есть пользоавтельские конструкторы, но нет конструктора без параметров, то во всех конструкторах потомка придется **явно** вызывать один из имеющихся базовых конструкторов.
5. Наследование реализует отношение is-a (является) `Потомок is Родитель = true`.
6. `Object` - предок любого класса. От него все классы получают методы: `ToString(), Equals(), GetHashCode(), GetType()`.
7.  Тип доступа к производному классу должен быть таким же, как и у базового класса, или более строгим. (`public -> internal -> private`)

---
#### Примеры

```csharp
class BaseClass // Базовый класс
{
	public BaseClass(): {} // через this можно
}

class DerivedClass : BaseClass // Производный класс
{
	public DerivedClass() : base() {} // вызов конструктора базового класса (с возможностью дополнения)
	public DerivedClass() {} // то же самое, только вызов КБК происходит неявно
}
```

```csharp
class Фигура
{
    public Фигура(double ширина, double высота)
    {
        ...
    }

    public virtual void ВывестиИнформация()
    {
        ...
    }
}

class Прямоугольник : Фигура
{
    public Прямоугольник(double ширина, double высота) : base(ширина, высота) {}

    public override void ВывестиИнформация()
    {
        base.ВывестиИнформация(); // Вызов метода базового класса
        Console.WriteLine("Тип фигуры: Прямоугольник");
    }
}
```

### Внутренние ссылки
[3. Модификаторы доступа](1.%20Languages/C-sharp/0.%20Введение/1.%20Области%20видимости/3.%20Модификаторы%20доступа.md)
[1. Классы](1.%20Languages/C-sharp/0.%20Введение/2.%20Классы%20и%20структуры/1.%20Классы.md)
### Внешние ссылки
