#Csharp 
# <font color="#00b0f0">C#:</font> Garbage Collector

**Сборщик мусора (GC)** - автоматически управляет памятью, выделенной для объектов в управляемой куче, выполняя её очистку и дефрагментацию.
- **Очистка** - запускается, когда программе требуется память.
- **Дефрагментация** - все значения пакуются в один цельный блок памяти а ссылки обновляются. В *Large Object Heap* (объекты >85 000 байт) дефрагментация не производится.

**Поколения объектов**: <font color="#ffff00">П0</font> - не подв. сборке, <font color="#ffff00">П1</font> - 1 сборка, <font color="#ffff00">П2</font> - >1 сборки
- Чем моложе поколение, тем меньше издержки на очистку.
- Каждая очистка поднимает оставшиеся объекты на 1 поколение (до П2 макс.).
- Очистка продолжается пока не хватит памяти.
- Очистка идет по порядку поколений П0->П1->П2

Другие темы:
[Неуправляемые объекты](1.%20Languages/C-sharp/GC/Неуправляемые%20объекты.md) по умолчанию не контролируются сборщиком.
[Указатели](1.%20Languages/C-sharp/GC/Указатели.md) позволяют манипулировать памятью напрямую.

---
### Практика:

Класс `System.GC` - требуется для краткосрочного выделения больших участков памяти под крупные объекты.
- `GC.AddMemoryPressure(int)` - уведомление CLR о резервировании памяти
- `GC.RemoveMemoryPressure(int)` - уведомление CLR об освобождении памяти
- `GC.GetGeneration(Object)` - поколение объекта.
- `GC.GetTotalMemory()` - объем занятой памяти управляемой кучей
- `GC.WaitForPendingFinalizers()` - приостановка потока до завершения сборки мусора
- `GC.Collect()` - ручной запуск сборки мусора (можно указать поколение объектов и время запуска (`GCCollectionMode`: `Default` / `Forced`: немедленное выполнение, `Optimized`: на усмотрение сборщика)

```csharp
long totalMemory = GC.GetTotalMemory(false);

GC.Collect();
GC.WaitForPendingFinalizers();
```

### Outer links:
https://metanit.com/sharp/tutorial/8.1.php

