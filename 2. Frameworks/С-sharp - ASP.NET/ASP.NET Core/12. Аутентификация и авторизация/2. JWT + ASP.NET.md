#lang #lang-c_sharp #aspnet

---
Атрибут `Authorize` - доступ к маршруту с таким атрибутом, ограничен только для аутентифицированных пользователей, которые имеют токен в заголовке запроса:
```json
"Authorization": "Bearer " + token  // token - полученный ранее jwt-токен
```

### 1. Сохраним все параметры токена в отдельном классе:

```csharp
public class AuthOptions
{
	public const string ISSUER = "MyAuthServer"; // издатель токена
	public const string AUDIENCE = "MyAuthClient"; // потребитель токена
	const string KEY = "mysupersecret_secretsecretsecretkey!123";   // ключ для шифрации
	// Для генерации токена нам необходим объект класса SecurityKey. В качестве такого здесь выступает объект производного класса SymmetricSecurityKey, в конструктор которого передается массив байт, созданный по секретному ключу.
	public static SymmetricSecurityKey GetSymmetricSecurityKey() => 
		new SymmetricSecurityKey(Encoding.UTF8.GetBytes(KEY));
}
```

### 2. С помощью опций настраиваем проверку токена при аутентификации:

```csharp
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            // указывает, будет ли валидироваться издатель при валидации токена
            ValidateIssuer = true,
            // строка, представляющая издателя
            ValidIssuer = AuthOptions.ISSUER,
            // будет ли валидироваться потребитель токена
            ValidateAudience = true,
            // установка потребителя токена
            ValidAudience = AuthOptions.AUDIENCE,
            // будет ли валидироваться время существования
            ValidateLifetime = true,
            // установка ключа безопасности
            IssuerSigningKey = AuthOptions.GetSymmetricSecurityKey(),
            // валидация ключа безопасности
            ValidateIssuerSigningKey = true,
         };
});
```

### 3. Генерируем токен и записываем его в куки ответа сервера:
2 способа: Оба способа создают JWT-токен с подписью HMAC SHA-256, но различаются подходом к формированию токена.
 
1. **Первый способ (с использованием `SecurityTokenDescriptor`)**  
	Первый способ (`SecurityTokenDescriptor`) удобнее и предпочтительнее в большинстве случаев. Он делает код более читаемым и поддерживаемым, особенно при расширении токена новыми свойствами.
	**Более декларативный:**
	- Используется `SecurityTokenDescriptor`, который задаёт свойства токена в структурированном виде.
	- Упрощает добавление новых параметров (например, аудитории, издателя).
	- Удобен при работе с `JwtSecurityTokenHandler`, который автоматически обрабатывает параметры.
	```csharp
	// Задача:
	// 1. Отправить `POST` на `/api/auth/login` с `{"username": "admin", "password": "password"}`.
	// 2. Получить JWT и использовать его в `Authorization: Bearer {токен}` для `/api/secure`.
	using Microsoft.AspNetCore.Mvc;
	using Microsoft.IdentityModel.Tokens;
	using System.IdentityModel.Tokens.Jwt;
	using System.Security.Claims;
	using System.Text;
	
	[Route("api/auth")]
	[ApiController]
	public class AuthController : ControllerBase
	{
		private const string SecretKey = "МойСекретныйКлюч123!"; 
	
		[HttpPost("login")]
		public IActionResult Login([FromBody] LoginModel model)
		{
			if (model.Username != "admin" || model.Password != "password")
				return Unauthorized();
	
			var tokenHandler = new JwtSecurityTokenHandler();
			var key = Encoding.UTF8.GetBytes(SecretKey);
			var tokenDescriptor = new SecurityTokenDescriptor
			{
				Subject = new ClaimsIdentity(new[]
				{
					new Claim(ClaimTypes.Name, model.Username),
					new Claim(ClaimTypes.Role, "Admin")
				}),
				Expires = DateTime.UtcNow.AddHours(1),
				SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature)
			};
	
			var token = tokenHandler.CreateToken(tokenDescriptor);
			return Ok(new { Token = tokenHandler.WriteToken(token) });
		}
	}
	
	public class LoginModel
	{
		public string Username { get; set; }
		public string Password { get; set; }
	}
	```

2. **Второй способ (с использованием `JwtSecurityToken`)**  
	Второй вариант может быть полезен при необходимости гибкой настройки токена, но чаще выглядит избыточным.
	**Более явный и ручной:**
	- Прямое создание объекта `JwtSecurityToken`.
	- Все параметры (издатель, аудитория, ключ) задаются вручную.
	- Используется `AuthOptions` (см шаг 1), что удобно для централизованного управления параметрами.
		
	```csharp
	app.Map("/login/{username}", (string username) => 
	{
		// некоторые данные о пользователе. Затем их можно применять для аутентификации. 
		// В данном случае добавляем в список один Claim, который хранит логин пользователя.
		var claims = new List<Claim> {new Claim(ClaimTypes.Name, username) };
		// создаем JWT-токен
		var jwt = new JwtSecurityToken(
				issuer: AuthOptions.ISSUER,
				audience: AuthOptions.AUDIENCE,
				claims: claims,
				expires: DateTime.UtcNow.Add(TimeSpan.FromMinutes(2)),
				signingCredentials: new SigningCredentials(AuthOptions.GetSymmetricSecurityKey(), SecurityAlgorithms.HmacSha256));
				
		return new JwtSecurityTokenHandler().WriteToken(jwt);
	});
	```

### 4. Создадим защищённый контроллер.
- `[Authorize]` требует JWT для доступа.
- Без токена запрос получит `401 Unauthorized`.

```csharp
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

[Route("api/secure")]
[ApiController]
[Authorize] // Требуется JWT для доступа
public class SecureController : ControllerBase
{
    [HttpGet]
    public IActionResult GetSecureData()
    {
        return Ok(new { Message = "Доступ разрешён!" });
    }
}
```
или так:
```csharp
app.Map("/data", [Authorize] () => new { message= "Hello World!" });
 
app.Run();
```

### Outer links:
https://metanit.com/sharp/aspnet6/13.2.php
https://metanit.com/sharp/aspnet6/13.3.php