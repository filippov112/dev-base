#lang #lang-c_sharp #aspnet

---
**Способы:**
1. Через свойство *Services* объекта *WebApplication* ([Локатор сервисов (Service locator)](8.%20Patterns/Проектирование/Порождающие/Локатор%20сервисов%20(Service%20locator).md))
2. Через свойство *RequestServices* контекста запроса *HttpContext* в компонентах middleware  ([Локатор сервисов (Service locator)](8.%20Patterns/Проектирование/Порождающие/Локатор%20сервисов%20(Service%20locator).md))
3. Через свойство *Services* объекта *WebApplicationBuilder*
4. Через *конструктор класса*
5. Через параметр *метода Invoke* компонента *middleware*


---
### 1. *Services* объекта *WebApplication*
Не рекомендуется без необходимости.
- `GetService<service>()`: возвращает значение null если не установлена зависимость
- `GetRequiredService<service>()`: генерирует исключение

```csharp
var builder = WebApplication.CreateBuilder();
 
builder.Services.AddTransient<ITimeService, ShortTimeService>();
 
var app = builder.Build();
 
app.Run(async context =>
{
    var timeService = app.Services.GetRequiredService<ITimeService>(); 
    await context.Response.WriteAsync($"Time: {timeService.GetTime()}");
});
 
app.Run();
```

---
### 2. *RequestServices* контекста запроса *HttpContext*
Аналог способа выше, только через другую переменную.

```csharp
var builder = WebApplication.CreateBuilder();
 
builder.Services.AddTransient<ITimeService, ShortTimeService>();
 
var app = builder.Build();
 
app.Run(async context =>
{
    var timeService = context.RequestServices.GetService<ITimeService>(); 
    await context.Response.WriteAsync($"Time: {timeService?.GetTime()}");
});
 
app.Run();
```


---
### 3. *Services* объекта *WebApplicationBuilder*
Те же яйца, только в профиль.

---

### 4. *Конструктор класса*
Предпочтительный способ для вложенных зависимостей (зависимостей зависимостей)).

1. Создаем некоторый класс, добавляем в параметры конструктора все зависимости.
2. Регистрируем сервисы для всех зависимостей данного класса.
3. Регистрируем сервис для самого класса.
4. В процессе работы приложения получаем экземпляр класса через первые 2 метода.

```csharp
var builder = WebApplication.CreateBuilder();
 
builder.Services.AddTransient<ITimeService, ShortTimeService>(); // <- регаем зависимости сервиса
builder.Services.AddTransient<TimeMessage>(); // <- регаем сам сервис
 
var app = builder.Build();
 
app.Run(async context =>
{
    var timeMessage = context.RequestServices.GetService<TimeMessage>(); // <- получаем экземпляр сервиса со всем деревом зависимостей.
    context.Response.ContentType = "text/html;charset=utf-8";
    await context.Response.WriteAsync($"<h2>{timeMessage?.GetTime()}</h2>");
});
 
app.Run();
 
class TimeMessage
{
    ITimeService timeService;
    public TimeMessage(ITimeService timeService) // <- прописываем параметрами от чего зависим
    {
        this.timeService = timeService;
    }
    public string GetTime() => $"Time: {timeService.GetTime()}";
}
interface ITimeService
{
    string GetTime();
}
class ShortTimeService : ITimeService
{
    public string GetTime() => DateTime.Now.ToShortTimeString();
}
```
---
### 5. Параметр *метода Invoke* или *конструктора* компонента *middleware*
Эффективная альтернатива *service locator*.

1. Создаем класс - middleware.
2. Передаем параметрами в *конструктор* или в *Invoke*/*InvokeAsync* все зависимости.
3. Подключаем middleware к приложению.

> [4. Жизненный цикл зависимостей](2.%20Frameworks/С-sharp%20-%20ASP.NET/ASP.NET%20Core/2.%20DI/4.%20Жизненный%20цикл%20зависимостей.md)
> - передача сервиса через *конструктор* больше подходит для *Singleton* сервисов, т.к. конструктор вызывается 1 раз за жизненный цикл приложения - при запуске.
> - сервисы типа *Scoped* или *Transient* лучше передавать через *Invoke*/*InvokeAsync*.

**Middleware:**
```csharp
class TimeMessageMiddleware
{
    private readonly RequestDelegate next;
    //ITimeService timeService;
 
    public TimeMessageMiddleware(RequestDelegate next)
    {
        this.next = next;
    }
 
    public async Task InvokeAsync(HttpContext context, ITimeService timeService)
    {
        context.Response.ContentType = "text/html;charset=utf-8";
        await context.Response.WriteAsync($"<h1>Time: {timeService.GetTime()}</h1>");
    }

	//public TimeMessageMiddleware(RequestDelegate next, ITimeService timeService)
    //{
    //    this.next = next;
    //    this.timeService = timeService;
    //}
 
    //public async Task InvokeAsync(HttpContext context)
    //{
    //    context.Response.ContentType = "text/html;charset=utf-8";
    //    await context.Response.WriteAsync($"<h1>Time: {timeService.GetTime()}</h1>");
    //}
}


interface ITimeService
{
    string GetTime();
}
class ShortTimeService : ITimeService
{
    public string GetTime() => DateTime.Now.ToShortTimeString();
}
```

**Подключение:**
```csharp
var builder = WebApplication.CreateBuilder();
builder.Services.AddTransient<ITimeService, ShortTimeService>();
 
var app = builder.Build();
 
app.UseMiddleware<TimeMessageMiddleware>(); // <-----------
app.Run();
```

---
### Outer links:
https://metanit.com/sharp/aspnet6/4.3.php
https://metanit.com/sharp/aspnet6/4.5.php